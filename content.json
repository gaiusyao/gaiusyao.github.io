{"meta":{"title":"Gaius Yao","subtitle":"Product Manager, Huge Nerd","description":null,"author":"Gaius Yao","url":"http://gaiusyao.cn"},"pages":[],"posts":[{"title":"数读《后汉书·郡国志》：用Hex Map查看数据分布","slug":"hex-map","date":"2018-02-03T16:00:00.000Z","updated":"2018-02-04T14:33:54.051Z","comments":true,"path":"2018/02/04/hex-map/","link":"","permalink":"http://gaiusyao.cn/2018/02/04/hex-map/","excerpt":"","text":"&emsp;&emsp;《后汉书·郡国志》记载的是东汉各级行政区划的历史沿革、山川奇异、风俗所由以及永和五年（即公元140年）的人口情况。笔者将《后汉书·郡国志》中记载的内容稍加整理，得到了一个105行7列的数据集（包括郡名、所属州、治所、城数、户数、人口数、历史沿革内容7个字段）。又为了获得更好的可视化效果，将6个属国并入了相关的郡国（如将广汉属国并入广汉郡），同时给数据集增加了两列位置坐标字段，略去了城数、历史沿革内容两个字段，得到了一个99行7列的新数据集，并将其转化为json格式。为了能更好地展现当时的人口分布情况，选用了Hex Map（六边形地图）进行数据可视化，最终结果如下（颜色越深的人口数量越大）： 东汉永和五年人口分布情况 注1：各郡国的位置参考了谭其骧主编的《中国历史地图集》注2：部分郡国的户数、人口数明显有误，如辽东郡，在合理推测的基础上进行了调整注3：缺少郁林、交趾二郡的户数和人口数，显示为淡粉色注4：《后汉书·郡国志》中记载的户数和人口数均为东汉户籍人口，还存在大量因豪强瞒报等原因游离在户籍之外的人口，这里不做展开 &emsp;&emsp;这里选用Hex Map的原因主要有三点： 可以省去各行政区划的面积等不必要的地理信息，减少信息干扰，以更好地观察数据； 部分面积过小的行政区划（如鲁国）也能得到很好的展现； 六边形较矩形可以保留更多的地理位置信息，更好地表现郡国间的地理位置关系。 &emsp;&emsp;当然了，对于一名老战棋玩家来说，使用Hex Map是十分的熟悉和亲切的，这一点也是很重要的。 &emsp;&emsp;接下来，就让我们开始通过Hex Map观察东汉永和五年（公元140年）的人口分布情况。首先，在上图中，我们可以看到东汉的人口多分布在东部，而西北的人口明显较少。若筛选掉人口在十万以下的郡国，河西走廊就全部变成灰色了。 人口十万以上的郡国 &emsp;&emsp;而筛选掉人口在二十万以下的郡国，则西北几乎全变成灰色。 人口二十万以上的郡国 &emsp;&emsp;而荆州、益州、司隶、豫州的人口明显较多，且包含人口在百万以上的郡国。在东汉末年，占据了这些州郡的军阀们，基本上都弄出了不小的动静。 人口一百万以上的郡国 &emsp;&emsp;我们再用Hex Map查看美国2012年的人口分布情况： 美国人口分布情况 &emsp;&emsp;当然，Hex Map不仅能看人口数据的分布情况，也可以看销售数量等数据的分布情况： 销量分布情况（虚拟数据） &emsp;&emsp;本文的所有可视化图形均基于AntV构建，详见AntV：美国地图六边形分割，源码及相关JSON文件如下，其中美国各州JSON来源为NPR Visuals，其余为本人创建： 源代码 美国各州JSON 中国各省JSON 东汉州郡JSON","categories":[{"name":"数读","slug":"数读","permalink":"http://gaiusyao.cn/categories/数读/"}],"tags":[{"name":"AntV","slug":"AntV","permalink":"http://gaiusyao.cn/tags/AntV/"}]},{"title":"Python数据可视化02：Seaborn","slug":"seaborn","date":"2018-01-20T02:00:00.000Z","updated":"2018-01-20T02:56:04.856Z","comments":true,"path":"2018/01/20/seaborn/","link":"","permalink":"http://gaiusyao.cn/2018/01/20/seaborn/","excerpt":"","text":"&emsp;&emsp;照例引用官方介绍“Seaborn是一个带着定制主题和高级界面控制的Matplotlib扩展包，能让绘图变得更轻松”，这里我们只需要知道Seaborn是一个用于数据可视化的包就行了，可以让我们用最少的代码去绘制一些描述性统计的图，便于找寻各维度变量之间的特征和关系，需要快速了解Seaborn的，可以查看Seaborn官方教程。接下来我们将通过一个经典数据集——鸢尾花来初步认识Seaborn。 0.开始前的准备&emsp;&emsp;Iris鸢尾花数据集是一个经典数据集，在统计学习和机器学习领域都经常被用作示例。数据集内包含3类共150条记录，每类各50个数据，每个数据都有4个属性：花萼长度、花萼宽度、花瓣长度、花瓣宽度，可以通过这4个属性预测鸢尾花卉属于（iris-setosa，iris-versicolour，iris-virginica）中的哪一类，但据说现实中，这三种花的基本判别依据其实是种子（因为花瓣非常容易枯萎）。&emsp;&emsp;在分析这个数据集之前，让我们先做好相关准备，包括导入相关包、导入数据集等。 12345678# 导入相关包import numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as plt# 导入数据集，也可以通过iris = sns.load_dataset(\"iris\") 导入iris = pd.read_csv('data/iris.csv', header=None) 12#设置列名iris.columns = ['sepal-length', 'sepal-width', 'petal-length', 'petal-width', 'species'] 12#查看数据集信息iris.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 150 entries, 0 to 149 Data columns (total 5 columns): sepal-length 150 non-null float64 sepal-width 150 non-null float64 petal-length 150 non-null float64 petal-width 150 non-null float64 species 150 non-null object dtypes: float64(4), object(1) memory usage: 5.9+ KB 12# 查看数据集头5条记录iris.head() output_4_0.png 12# 查看鸢尾花的所有种类iris['species'].unique() array([&apos;Iris-setosa&apos;, &apos;Iris-versicolor&apos;, &apos;Iris-virginica&apos;], dtype=object) &emsp;&emsp;完成这些准备工作后，我们可以通过seaborn对该数据集进行可视化分析。 1.Stripplot &amp; Swarmplot12# 设置seaborn样式sns.set_style(\"whitegrid\") seaborn.stripplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, jitter=False, dodge=False, orient=None, color=None, palette=None, size=5, edgecolor=’gray’, linewidth=0, ax=None, **kwargs) &emsp;&emsp;Stripplot主要用于绘制散点图，下面将鸢尾花数据集中的花萼长度属性按品种分类绘制成散点图分析： 1ax = sns.stripplot(x=\"species\", y=\"sepal-length\", data=iris) output_8_0.png &emsp;&emsp;通过jitter属性为散点图设置抖动，以便更好地观察数据。 1ax = sns.stripplot(x=\"species\", y=\"sepal-length\", data=iris, jitter=True) output_9_0.png 1ax = sns.stripplot(x=\"species\", y=\"sepal-length\", data=iris, jitter=0.05) output_10_0.png &emsp;&emsp;改变轴向观察数据。 1ax = sns.stripplot(x=\"sepal-length\", y=\"species\", data=iris, jitter=0.05) output_11_0.png &emsp;&emsp;通过改变颜色、样式、大小等更好地观察数据。 12antV = ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436c7', '#F04864']ax = sns.stripplot(x=\"sepal-length\", y=\"species\", data=iris, jitter=0.05, palette=antV) output_12_0.png 12ax = sns.stripplot(\"species\", \"sepal-length\", data=iris, palette=\"Set2\", size=12, marker=\"D\", jitter=0.05, edgecolor=\"gray\", alpha=.25) output_13_0.png seaborn.swarmplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, dodge=False, orient=None, color=None, palette=None, size=5, edgecolor=’gray’, linewidth=0, ax=None, **kwargs) &emsp;&emsp;Swarmplot也是绘制散点图，但它会通过算法，在类别坐标轴的方向上延展那些原本重合的点，与通过jitter属性增加抖动有异曲同工之妙。 1ax = sns.swarmplot(x=\"species\", y=\"sepal-length\", data=iris) output_15_0.png &emsp;&emsp;现在我们通过Swarmplot观察花萼长度、花萼宽度、花瓣长度、花瓣宽度与类别之间的关系。 12345678910f, axes = plt.subplots(2, 2, figsize=(12, 12), sharex=True)sns.despine(left=True)sns.swarmplot(x=\"species\", y=\"sepal-length\", data=iris, palette=antV, ax=axes[0, 0])sns.swarmplot(x=\"species\", y=\"sepal-width\", data=iris, palette=antV, ax=axes[0, 1])sns.swarmplot(x=\"species\", y=\"petal-length\", data=iris, palette=antV, ax=axes[1, 0])sns.swarmplot(x=\"species\", y=\"petal-width\", data=iris, palette=antV, ax=axes[1, 1])plt.setp(axes, yticks=[])plt.tight_layout() output_16_0.png 2.Boxplot &amp; Violinplot seaborn.boxplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, width=0.8, dodge=True, fliersize=5, linewidth=None, whis=1.5, notch=False, ax=None, **kwargs) &emsp;&emsp;通过Boxplot可以看到数据的最大值、上四分位数Q3、中位数、下四分位数Q1、最小值和异常值的分布。 12345678910f, axes = plt.subplots(2, 2, figsize=(12, 12), sharex=True)sns.despine(left=True)sns.boxplot(x=\"species\", y=\"sepal-length\", data=iris, palette='Set2', ax=axes[0, 0])sns.boxplot(x=\"species\", y=\"sepal-width\", data=iris, palette='Set2', ax=axes[0, 1])sns.boxplot(x=\"species\", y=\"petal-length\", data=iris, palette='Set2', ax=axes[1, 0])sns.boxplot(x=\"species\", y=\"petal-width\", data=iris, palette='Set2', ax=axes[1, 1])plt.setp(axes, yticks=[])plt.tight_layout() output_18_0.png seaborn.violinplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, bw=’scott’, cut=2, scale=’area’, scale_hue=True, gridsize=100, width=0.8, inner=’box’, split=False, dodge=True, orient=None, linewidth=None, color=None, palette=None, saturation=0.75, ax=None, **kwargs) &emsp;&emsp;Violinplot与Boxplot相似，但其图形如同小提琴般，可以更好地展现出数据的量化形态。 1234567891011# Set up the matplotlib figuref, axes = plt.subplots(2, 2, figsize=(12, 12), sharex=True)sns.despine(left=True)sns.violinplot(x=\"species\", y=\"sepal-length\", data=iris, palette='Set2', ax=axes[0, 0])sns.violinplot(x=\"species\", y=\"sepal-width\", data=iris, palette='Set2', ax=axes[0, 1])sns.violinplot(x=\"species\", y=\"petal-length\", data=iris, palette='Set2', ax=axes[1, 0])sns.violinplot(x=\"species\", y=\"petal-width\", data=iris, palette='Set2', ax=axes[1, 1])plt.setp(axes, yticks=[])plt.tight_layout() output_20_0.png &emsp;&emsp;可以Stripplot &amp; Swarmplot与Boxplot &amp; Violinplot将相组合，以更好地查看数据分布情况。 12ax = sns.violinplot(x=\"species\", y=\"sepal-length\", data=iris, palette='Set2')ax = sns.swarmplot(x=\"species\", y=\"sepal-length\", data=iris, color=\"white\", edgecolor=\"gray\") output_21_0.png 3.Barplot seaborn.barplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, estimator=, ci=95, n_boot=1000, units=None, orient=None, color=None, palette=None, saturation=0.75, errcolor=’.26’, errwidth=None, capsize=None, dodge=True, ax=None, **kwargs) &emsp;&emsp;Barplot主要是绘制条形图，利用条形的高度反映数值变量的集中趋势，在条形顶部还有误差棒。 12345678910f, axes = plt.subplots(2, 2, figsize=(10, 10), sharex=True)sns.despine(left=True)sns.barplot(x=\"species\", y=\"sepal-length\", data=iris, palette='Set2', ax=axes[0, 0])sns.barplot(x=\"species\", y=\"sepal-width\", data=iris, palette='Set2', ax=axes[0, 1])sns.barplot(x=\"species\", y=\"petal-length\", data=iris, palette='Set2', ax=axes[1, 0])sns.barplot(x=\"species\", y=\"petal-width\", data=iris, palette='Set2', ax=axes[1, 1])plt.setp(axes, yticks=[])plt.tight_layout() output_23_0.png 4.Countplot seaborn.countplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, dodge=True, ax=None, **kwargs) &emsp;&emsp;Countplot可以直观地查看每个类别下有多少个观察值。 1ax = sns.countplot(y=\"species\", data=iris, palette=\"Set3\") output_25_0.png 5.Pointplot seaborn.pointplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, estimator=, ci=95, n_boot=1000, units=None, markers=’o’, linestyles=’-‘, dodge=False, join=True, scale=1, orient=None, color=None, palette=None, errwidth=None, capsize=None, ax=None, **kwargs) &emsp;&emsp;Pointplot可以通过斜率很容易地看出各类别间的主要关系。12345678910f, axes = plt.subplots(2, 2, figsize=(10, 10), sharex=True)sns.despine(left=True)sns.pointplot(x=\"species\", y=\"sepal-length\", data=iris, ax=axes[0, 0])sns.pointplot(x=\"species\", y=\"sepal-width\", data=iris, ax=axes[0, 1])sns.pointplot(x=\"species\", y=\"petal-length\", data=iris, ax=axes[1, 0])sns.pointplot(x=\"species\", y=\"petal-width\", data=iris, ax=axes[1, 1])plt.setp(axes, yticks=[])plt.tight_layout() output_27_0.png 6. Factorplot seaborn.factorplot(x=None, y=None, hue=None, data=None, row=None, col=None, col_wrap=None, estimator=, ci=95, n_boot=1000, units=None, order=None, hue_order=None, row_order=None, col_order=None, kind=’point’, size=4, aspect=1, orient=None, color=None, palette=None, legend=True, legend_out=True, sharex=True, sharey=True, margin_titles=False, facet_kws=None, **kwargs) &emsp;&emsp;Factorplot将上述的函数与FacetGrid结合起来，通过设置kind属性，可以变化成不同的图形。 12sns.factorplot(x=\"species\", y=\"sepal-length\", data=iris, kind=\"violin\")sns.factorplot(x=\"species\", y=\"sepal-width\", data=iris, kind=\"box\"); output_29_0.png output_29_1.png 7. PairGrid class seaborn.PairGrid(data, hue=None, hue_order=None, palette=None, hue_kws=None, vars=None, x_vars=None, y_vars=None, diag_sharey=True, size=2.5, aspect=1, despine=True, dropna=True) &emsp;&emsp;PairGrid可以用于绘制展现数据集内多个变量之间关系的矩阵图。 12g = sns.PairGrid(data=iris, palette=antV, hue=\"species\")g = g.map(plt.scatter) output_31_0.png 1234g = sns.PairGrid(data=iris, palette=antV, hue=\"species\")g = g.map_diag(plt.hist)g = g.map_offdiag(plt.scatter)g = g.add_legend() output_32_0.png","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python数据可视化","slug":"人生苦短，我用Python/Python数据可视化","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python数据可视化/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://gaiusyao.cn/tags/数据可视化/"}]},{"title":"Python数据可视化01：Pandas","slug":"pandas","date":"2018-01-09T10:07:00.000Z","updated":"2018-01-20T01:11:02.299Z","comments":true,"path":"2018/01/09/pandas/","link":"","permalink":"http://gaiusyao.cn/2018/01/09/pandas/","excerpt":"","text":"1.pandas简介&emsp; &emsp; 首先引用官方介绍：“pandas是一个采用BSD协议的开源库，为Python编程语言提供了高性能，易于使用的数据结构和数据分析工具。”这里不做过多展开，需要快速了解pandas的可以尝试官方教程Ten_Minutes_to_Pandas（已汉化），让我们马上通过一个实例来展示pandas的功能吧！首先导入相关库： 123456# 导入相关库import pandas as pdimport numpy as npimport matplotlib.pyplot as plt import datetimeimport re 2.文件读取&emsp;&emsp;这里以读取csv文件为例，介绍3种常用的数据读取函数： df = pd.read_csv(path=’file.csv’) df = pd.read_json(‘file.json’) #可以传入json格式字符串 df = pd.read_excel(‘file.xls’, sheetname=[0,1..]) #读取多个sheet，返回多个df的字典 123# 导入数据集dc = pd.read_csv('data/dc.csv')marvel = pd.read_csv('data/marvel.csv') 3.查看DateFrame&emsp;&emsp;在导入数据集后，我们可以通过下列函数来查看DateFrame： df.info() #查看DateFrame信息 df.describe() #描述性统计 df.columns #查看列名 df.index #查看索引 df.head() #查看DateFrame头五行 df.tail() #查看DateFrame尾五行 1dc.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 6896 entries, 0 to 6895 Data columns (total 13 columns): page_id 6896 non-null int64 name 6896 non-null object urlslug 6896 non-null object ID 4883 non-null object ALIGN 6295 non-null object EYE 3268 non-null object HAIR 4622 non-null object SEX 6771 non-null object GSM 64 non-null object ALIVE 6893 non-null object APPEARANCES 6541 non-null float64 FIRST APPEARANCE 6827 non-null object YEAR 6827 non-null float64 dtypes: float64(2), int64(1), object(10) memory usage: 700.5+ KB 1marvel.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 16376 entries, 0 to 16375 Data columns (total 13 columns): page_id 16376 non-null int64 name 16376 non-null object urlslug 16376 non-null object ID 12606 non-null object ALIGN 13564 non-null object EYE 6609 non-null object HAIR 12112 non-null object SEX 15522 non-null object GSM 90 non-null object ALIVE 16373 non-null object APPEARANCES 15280 non-null float64 FIRST APPEARANCE 15561 non-null object Year 15561 non-null float64 dtypes: float64(2), int64(1), object(10) memory usage: 1.6+ MB 1dc.columns Index([&apos;page_id&apos;, &apos;name&apos;, &apos;urlslug&apos;, &apos;ID&apos;, &apos;ALIGN&apos;, &apos;EYE&apos;, &apos;HAIR&apos;, &apos;SEX&apos;, &apos;GSM&apos;, &apos;ALIVE&apos;, &apos;APPEARANCES&apos;, &apos;FIRST APPEARANCE&apos;, &apos;YEAR&apos;], dtype=&apos;object&apos;) 1marvel.columns Index([&apos;page_id&apos;, &apos;name&apos;, &apos;urlslug&apos;, &apos;ID&apos;, &apos;ALIGN&apos;, &apos;EYE&apos;, &apos;HAIR&apos;, &apos;SEX&apos;, &apos;GSM&apos;, &apos;ALIVE&apos;, &apos;APPEARANCES&apos;, &apos;FIRST APPEARANCE&apos;, &apos;Year&apos;], dtype=&apos;object&apos;) 12# 统一列名marvel.rename(columns=&#123;'Year':'YEAR'&#125;, inplace = True) 1dc.index RangeIndex(start=0, stop=6896, step=1) 1dc.head() #结果略 1marvel.tail() #结果略 4.缺失值处理&emsp;&emsp;在上一步，我们可以看到DateFrame中有不少数据是缺失的（显示为NaN），我们可以通过dropna()函数去掉含有缺失数据的行，但在这里，我们希望保留这些行，因此使用fillna()函数填充缺失的数据： 12# 将marvel数据集EYE列缺失的数据填充为Unknowmarvel['EYE'].fillna('UnKnown') 0 Hazel Eyes 1 Blue Eyes 2 Blue Eyes 3 Blue Eyes 4 Blue Eyes 5 Blue Eyes 6 Brown Eyes 7 Brown Eyes 8 Brown Eyes 9 Blue Eyes 10 Blue Eyes 11 Blue Eyes 12 Green Eyes 13 Blue Eyes 14 Blue Eyes 15 Blue Eyes 16 Grey Eyes 17 Green Eyes 18 Blue Eyes 19 Brown Eyes 20 Blue Eyes 21 Blue Eyes 22 Blue Eyes 23 Blue Eyes 24 Green Eyes 25 Brown Eyes 26 Blue Eyes 27 Green Eyes 28 Green Eyes 29 Yellow Eyes ... 16346 UnKnown 16347 UnKnown 16348 UnKnown 16349 White Eyes 16350 UnKnown 16351 UnKnown 16352 UnKnown 16353 UnKnown 16354 UnKnown 16355 UnKnown 16356 UnKnown 16357 UnKnown 16358 UnKnown 16359 Black Eyes 16360 Black Eyes 16361 UnKnown 16362 Red Eyes 16363 Black Eyes 16364 Hazel Eyes 16365 UnKnown 16366 Brown Eyes 16367 Hazel Eyes 16368 UnKnown 16369 Blue Eyes 16370 UnKnown 16371 Green Eyes 16372 Blue Eyes 16373 Black Eyes 16374 UnKnown 16375 UnKnown Name: EYE, Length: 16376, dtype: object 1dc['EYE'].fillna('UnKnown') #结果略 5.添加/插入行列&emsp;&emsp;接下来我们为两个DateFrame添加COMPANY列，并演示如何插入行列。其中插入行的过程会略复杂，需要先切割，再拼接。 1marvel['COMPANY'] = 'Marvel' 1dc['COMPANY'] = 'DC' 12# 查看是否添加成功dc.head() #结果略 12# 将page_id列取出page_id = dc.pop('page_id') 12# 检查是否取出成功dc.head() #结果略 12# 重新插入page_id列dc.insert(0, 'page_id', page_id) 12# 检查是否插入成功dc.head() #结果略 123456789# 创建需要插入的行的数据insertRow = pd.DataFrame([[42, 'Gaius', 'Unknown', 'Secret Identity', 'Good Characters','Blake Eyes', 'Black Hair', 'Male Characters', 'Unknown', 'Living Characters', '2333.0', '1995, August', '1995', 'Unknown']], columns=['page_id', 'name', 'urlslug', 'ID', 'ALIGN', 'EYE', 'HAIR', 'SEX', 'GSM', 'ALIVE', 'APPEARANCES', 'FIRST APPEARANCE', 'YEAR', 'COMPANY'])# 将dc分割为above和belowabove = dc.loc[:2]below = dc.loc[3:]# 拼接above和belowdc = above.append(insertRow,ignore_index=True).append(below,ignore_index=True)dc.head() #结果略 6.合并DateFrame&emsp;&emsp;通过concat()函数合并DateFrame——pd.concat(list)，list中为各个DateFrame。 1comic = pd.concat([dc, marvel], ignore_index=True) 1comic.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 23273 entries, 0 to 23272 Data columns (total 14 columns): page_id 23273 non-null int64 name 23273 non-null object urlslug 23273 non-null object ID 23273 non-null object ALIGN 23273 non-null object EYE 23273 non-null object HAIR 23273 non-null object SEX 23273 non-null object GSM 23273 non-null object ALIVE 23273 non-null object APPEARANCES 23273 non-null object FIRST APPEARANCE 23273 non-null object YEAR 23273 non-null object COMPANY 23273 non-null object dtypes: int64(1), object(13) memory usage: 2.5+ MB 1comic.head() #结果略 7.导出数据&emsp;&emsp;通过to_csv()函数导出数据： 1comic.to_csv('data/comic_characters.csv') &emsp;&emsp;至此，我们已经通过pandas将两个数据集合为了一个，下一期将会使用seaborn对该数据集进行可视化的工作。 marvel.csv dc.csv","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python数据可视化","slug":"人生苦短，我用Python/Python数据可视化","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python数据可视化/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://gaiusyao.cn/tags/数据可视化/"}]},{"title":"Python分析葡萄酒质量","slug":"wine-quality","date":"2017-11-04T12:30:48.000Z","updated":"2018-01-10T05:51:55.145Z","comments":true,"path":"2017/11/04/wine-quality/","link":"","permalink":"http://gaiusyao.cn/2017/11/04/wine-quality/","excerpt":"","text":"本篇博文是作者在阅读完Foundations for Analytics with Python一书后，使用Python进行数据分析的一次实战，所用数据集为葡萄酒质量数据集，该数据集是由UCI机器学习资料库中找到的两个数据集合并成的: 红葡萄酒 白葡萄酒 1.描述性统计1.1 将数据集读入数据框 在下面的代码中，首先完成了import工作，将所需的包加载到脚本中。之后用pandas的read_csv方法将文本文件csv\\winequality-both.csv读入到数据框wine中，并将列标题中包含的空格替换为_。最后通过head方法打印出下标题行和前5行数据，以确保数据被正确地加载。 123456789101112#!/usr/bin/env python3import numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltimport statsmodels.api as smimport statsmodels.formula.api as smffrom statsmodels.formula.api import ols, glmwine = pd.read_csv('csv\\winequality-both.csv', sep=',', header=0)wine.columns = wine.columns.str.replace(' ', '_')print(wine.head()) type fixed_acidity volatile_acidity citric_acid residual_sugar \\ 0 red 7.4 0.70 0.00 1.9 1 red 7.8 0.88 0.00 2.6 2 red 7.8 0.76 0.04 2.3 3 red 11.2 0.28 0.56 1.9 4 red 7.4 0.70 0.00 1.9 chlorides free_sulfur_dioxide total_sulfur_dioxide density pH \\ 0 0.076 11.0 34.0 0.9978 3.51 1 0.098 25.0 67.0 0.9968 3.20 2 0.092 15.0 54.0 0.9970 3.26 3 0.075 17.0 60.0 0.9980 3.16 4 0.076 11.0 34.0 0.9978 3.51 sulphates alcohol quality 0 0.56 9.4 5 1 0.68 9.8 5 2 0.65 9.8 5 3 0.58 9.8 6 4 0.56 9.4 5 1.2 显示所有变量的描述性统计量 通过describe方法，打印出在所有变量的描述性统计量，包括总数、均值、标准差、最小值、第25个百分位数、中位数、第75个百分位数和最大值。 1print(wine.describe()) fixed_acidity volatile_acidity citric_acid residual_sugar \\ count 6497.000000 6497.000000 6497.000000 6497.000000 mean 7.215307 0.339666 0.318633 5.443235 std 1.296434 0.164636 0.145318 4.757804 min 3.800000 0.080000 0.000000 0.600000 25% 6.400000 0.230000 0.250000 1.800000 50% 7.000000 0.290000 0.310000 3.000000 75% 7.700000 0.400000 0.390000 8.100000 max 15.900000 1.580000 1.660000 65.800000 chlorides free_sulfur_dioxide total_sulfur_dioxide density \\ count 6497.000000 6497.000000 6497.000000 6497.000000 mean 0.056034 30.525319 115.744574 0.994697 std 0.035034 17.749400 56.521855 0.002999 min 0.009000 1.000000 6.000000 0.987110 25% 0.038000 17.000000 77.000000 0.992340 50% 0.047000 29.000000 118.000000 0.994890 75% 0.065000 41.000000 156.000000 0.996990 max 0.611000 289.000000 440.000000 1.038980 pH sulphates alcohol quality count 6497.000000 6497.000000 6497.000000 6497.000000 mean 3.218501 0.531268 10.491801 5.818378 std 0.160787 0.148806 1.192712 0.873255 min 2.720000 0.220000 8.000000 3.000000 25% 3.110000 0.430000 9.500000 5.000000 50% 3.210000 0.510000 10.300000 6.000000 75% 3.320000 0.600000 11.300000 6.000000 max 4.010000 2.000000 14.900000 9.000000 1.3 分析质量列 从1.2中的结果我们可以得知，质量列中有6497个观测，范围从3到9，平均数为5.8，标准差为0.87。通过unique方法，识别出质量列中的唯一值，并以升序打印在屏幕上，输出显示质量列中的唯一值是3、4、5、6、7、8 和9。 1print(sorted(wine.quality.unique())) [3, 4, 5, 6, 7, 8, 9] 接着计算质量列中唯一值出现的频率，可以看到质量评分为6的最多，有2836个观测，而质量评分最高分9则最少，只有5个观测。 1print(wine.quality.value_counts()) 6 2836 5 2138 7 1079 4 216 8 193 3 30 9 5 Name: quality, dtype: int64 1.4 分组显示 前面计算出的统计量是针对整个数据集的，既包括红葡萄酒数据也包括白葡萄酒数据。下面通过groupby方法，按照葡萄酒类型（type）分别显示红葡萄酒和白葡萄酒的描述性统计量。 1print(wine.groupby('type')[['alcohol']].describe().unstack('type')) type alcohol count red 1599.000000 white 4898.000000 mean red 10.422983 white 10.514267 std red 1.065668 white 1.230621 min red 8.400000 white 8.000000 25% red 9.500000 white 9.500000 50% red 10.200000 white 10.400000 75% red 11.100000 white 11.400000 max red 14.900000 white 14.200000 dtype: float64 接着，使用quantile函数对质量列计算第25百分位数和第75百分位数，并按照葡萄酒类型显示。 1print(wine.groupby('type')[['quality']].quantile([0.25, 0.75]).unstack('type')) quality type red white 0.25 5.0 5.0 0.75 6.0 6.0 1.5 相关矩阵 这里通过corr方法计算得到所有变量的相关矩阵，结果将会在后面用到。 1print(wine.corr()) fixed_acidity volatile_acidity citric_acid \\ fixed_acidity 1.000000 0.219008 0.324436 volatile_acidity 0.219008 1.000000 -0.377981 citric_acid 0.324436 -0.377981 1.000000 residual_sugar -0.111981 -0.196011 0.142451 chlorides 0.298195 0.377124 0.038998 free_sulfur_dioxide -0.282735 -0.352557 0.133126 total_sulfur_dioxide -0.329054 -0.414476 0.195242 density 0.458910 0.271296 0.096154 pH -0.252700 0.261454 -0.329808 sulphates 0.299568 0.225984 0.056197 alcohol -0.095452 -0.037640 -0.010493 quality -0.076743 -0.265699 0.085532 residual_sugar chlorides free_sulfur_dioxide \\ fixed_acidity -0.111981 0.298195 -0.282735 volatile_acidity -0.196011 0.377124 -0.352557 citric_acid 0.142451 0.038998 0.133126 residual_sugar 1.000000 -0.128940 0.402871 chlorides -0.128940 1.000000 -0.195045 free_sulfur_dioxide 0.402871 -0.195045 1.000000 total_sulfur_dioxide 0.495482 -0.279630 0.720934 density 0.552517 0.362615 0.025717 pH -0.267320 0.044708 -0.145854 sulphates -0.185927 0.395593 -0.188457 alcohol -0.359415 -0.256916 -0.179838 quality -0.036980 -0.200666 0.055463 total_sulfur_dioxide density pH sulphates \\ fixed_acidity -0.329054 0.458910 -0.252700 0.299568 volatile_acidity -0.414476 0.271296 0.261454 0.225984 citric_acid 0.195242 0.096154 -0.329808 0.056197 residual_sugar 0.495482 0.552517 -0.267320 -0.185927 chlorides -0.279630 0.362615 0.044708 0.395593 free_sulfur_dioxide 0.720934 0.025717 -0.145854 -0.188457 total_sulfur_dioxide 1.000000 0.032395 -0.238413 -0.275727 density 0.032395 1.000000 0.011686 0.259478 pH -0.238413 0.011686 1.000000 0.192123 sulphates -0.275727 0.259478 0.192123 1.000000 alcohol -0.265740 -0.686745 0.121248 -0.003029 quality -0.041385 -0.305858 0.019506 0.038485 alcohol quality fixed_acidity -0.095452 -0.076743 volatile_acidity -0.037640 -0.265699 citric_acid -0.010493 0.085532 residual_sugar -0.359415 -0.036980 chlorides -0.256916 -0.200666 free_sulfur_dioxide -0.179838 0.055463 total_sulfur_dioxide -0.265740 -0.041385 density -0.686745 -0.305858 pH 0.121248 0.019506 sulphates -0.003029 0.038485 alcohol 1.000000 0.444319 quality 0.444319 1.000000 2.直方图与t检验 这里通过seaborn包创建一幅统计图，图中有两个直方图，分别表示红葡萄酒和白葡萄酒。从下图可以看出，两种葡萄酒的评分都近似正态分布。与原始数据的摘要统计量相比，直方图更容易看出两种葡萄酒的质量评分的分布。 12345678910red_wine = wine.loc[wine['type']=='red', 'quality']white_wine = wine.loc[wine['type']=='white', 'quality']sns.set_style(\"dark\")print(sns.distplot(red_wine, \\norm_hist=True, kde=False, color=\"red\", label=\"Red wine\", axlabel=False))print(sns.distplot(white_wine, \\norm_hist=True, kde=False, color=\"white\", label=\"White wine\", axlabel=False))plt.title(\"Distribution of Quality by Wine Type\")plt.legend()plt.show() 直方图 接着，进行一下t检验，判断红葡萄酒和白葡萄酒的平均评分是否有区别。下面的代码演示了如何使用groupby和agg函数来为数据集中的分组计算一系列统计量。从结果中，我们可以得知，白葡萄酒的平均质量评分在统计意义上大于红葡萄酒的平均质量评分。 123print(wine.groupby(['type'])[['quality']].agg(['std']))tstat, pvalue, df = sm.stats.ttest_ind(red_wine, white_wine)print('tstat: %.3f pvalue: %.4f' % (tstat, pvalue)) quality std type red 0.807569 white 0.885639 tstat: -9.686 pvalue: 0.0000 3.成对变量之间的关系和相关性 前面已经检查了输出变量，下面简单研究一下输入变量。让我们计算一下输入变量两两之间的相关性，在1.5我们用corr函数计算出数据集中所有变量的相关矩阵，它揭示了所有变量两两之间的线性相关性——酒精含量、硫酸盐、pH 值、游离二氧化硫和柠檬酸这些指标与质量是正相关的，相反，非挥发性酸、挥发性酸、残余糖分、氯化物、总二氧化硫和密度这些指标与质量是负相关的。下面的代码则将从红葡萄酒和白葡萄酒的数据中抽样取出一个“小”样本（200条红葡萄酒数据和200条白葡萄酒数据）来进行绘图，并通过seaborn的pairplot函数创建一个统计图矩阵。 123456789101112131415161718def take_sample(data_frame, replace=False, n=200): return data_frame.loc[np.random.choice(data_frame.index, replace=replace, size=n)]reds_sample = take_sample(wine.loc[wine['type']=='red', :])whites_sample = take_sample(wine.loc[wine['type']=='white', :])wine_sample = pd.concat([reds_sample, whites_sample])wine['in_sample'] = np.where(wine.index.isin(wine_sample.index), 1.,0.)print(pd.crosstab(wine.in_sample, wine.type, margins=True))sns.set_style(\"dark\")g = sns.pairplot(wine_sample, kind='reg', plot_kws=&#123;\"ci\": False,\\\"x_jitter\": 0.25, \"y_jitter\": 0.25&#125;, hue='type', diag_kind='hist',\\diag_kws=&#123;\"bins\": 10, \"alpha\": 1.0&#125;, palette=dict(red=\"red\", white=\"white\"),\\markers=[\"o\", \"s\"], vars=['quality', 'alcohol', 'residual_sugar'])print(g)plt.suptitle('Histograms and Scatter Plots of Quality, Alcohol, and Residual\\Sugar', fontsize=14, horizontalalignment='center', verticalalignment='top',\\x=0.5, y=0.999)plt.show() 下方的统计图矩阵显示了葡萄酒质量、酒精含量和残余糖分之间的关系。红条和红点表示红葡萄酒，白条和白点表示白葡萄酒。主对角线上的图以直方图或密度图的形式显示了每个变量的单变量分布，对角线之外的图以散点图的形式显示了每两个变量之间的双变量分布，散点图中可以有回归直线，也可以没有。 从这些统计图可以看出，对于红葡萄酒和白葡萄酒来说，酒精含量的均值和标准差是大致相同的，但是，白葡萄酒残余糖分的均值和标准差却大于红葡萄酒残余糖分的均值和标准差。从回归直线可以看出，对于两种类型的葡萄酒，酒精含量增加时，质量评分也随之提高，相反，残余糖分增加时，质量评分则随之降低。这两个变量对白葡萄酒的影响都要大于对红葡萄酒的影响。 4.使用最小二乘估计进行线性回归 这里使用使用statsmodel包来进行线性回归, 首先将一个包含回归公式定义的字符串赋给my_formula 。在该字符串中，~左侧的变量quality是因变量，右侧的均为自变量。接下来用公式和数据拟合一个普通最小二乘回归模型，并将结果赋给变量lm。最后打印模型的结果。 1234567891011my_formula = 'quality ~ alcohol + chlorides + citric_acid + density\\+ fixed_acidity + free_sulfur_dioxide + pH + residual_sugar + sulphates\\+ total_sulfur_dioxide + volatile_acidity'lm = ols(my_formula, data=wine).fit()print(lm.summary())print(\"\\nQuantities you can extract from the result:\\n%s\" % dir(lm))print(\"\\nCoefficients:\\n%s\" % lm.params)print(\"\\nCoefficient Std Errors:\\n%s\" % lm.bse)print(\"\\nAdj. R-squared:\\n%.2f\" % lm.rsquared_adj)print(\"\\nF-statistic: %.1f P-value: %.2f\" % (lm.fvalue, lm.f_pvalue))print(\"\\nNumber of obs: %d Number of fitted values: %s\" % (lm.nobs, len(lm.fittedvalues))) OLS Regression Results ============================================================================== Dep. Variable: quality R-squared: 0.292 Model: OLS Adj. R-squared: 0.291 Method: Least Squares F-statistic: 243.3 Date: Thu, 09 Nov 2017 Prob (F-statistic): 0.00 Time: 08:35:41 Log-Likelihood: -7215.5 No. Observations: 6497 AIC: 1.445e+04 Df Residuals: 6485 BIC: 1.454e+04 Df Model: 11 Covariance Type: nonrobust ======================================================================================== coef std err t P&gt;|t| [0.025 0.975] ---------------------------------------------------------------------------------------- Intercept 55.7627 11.894 4.688 0.000 32.447 79.079 alcohol 0.2670 0.017 15.963 0.000 0.234 0.300 chlorides -0.4837 0.333 -1.454 0.146 -1.136 0.168 citric_acid -0.1097 0.080 -1.377 0.168 -0.266 0.046 density -54.9669 12.137 -4.529 0.000 -78.760 -31.173 fixed_acidity 0.0677 0.016 4.346 0.000 0.037 0.098 free_sulfur_dioxide 0.0060 0.001 7.948 0.000 0.004 0.007 pH 0.4393 0.090 4.861 0.000 0.262 0.616 residual_sugar 0.0436 0.005 8.449 0.000 0.033 0.054 sulphates 0.7683 0.076 10.092 0.000 0.619 0.917 total_sulfur_dioxide -0.0025 0.000 -8.969 0.000 -0.003 -0.002 volatile_acidity -1.3279 0.077 -17.162 0.000 -1.480 -1.176 ============================================================================== Omnibus: 144.075 Durbin-Watson: 1.646 Prob(Omnibus): 0.000 Jarque-Bera (JB): 324.712 Skew: -0.006 Prob(JB): 3.09e-71 Kurtosis: 4.095 Cond. No. 2.49e+05 ============================================================================== Quantities you can extract from the result: [&apos;HC0_se&apos;, &apos;HC1_se&apos;, &apos;HC2_se&apos;, &apos;HC3_se&apos;, &apos;_HCCM&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_cache&apos;, &apos;_data_attr&apos;, &apos;_get_robustcov_results&apos;, &apos;_is_nested&apos;, &apos;_wexog_singular_values&apos;, &apos;aic&apos;, &apos;bic&apos;, &apos;bse&apos;, &apos;centered_tss&apos;, &apos;compare_f_test&apos;, &apos;compare_lm_test&apos;, &apos;compare_lr_test&apos;, &apos;condition_number&apos;, &apos;conf_int&apos;, &apos;conf_int_el&apos;, &apos;cov_HC0&apos;, &apos;cov_HC1&apos;, &apos;cov_HC2&apos;, &apos;cov_HC3&apos;, &apos;cov_kwds&apos;, &apos;cov_params&apos;, &apos;cov_type&apos;, &apos;df_model&apos;, &apos;df_resid&apos;, &apos;diagn&apos;, &apos;eigenvals&apos;, &apos;el_test&apos;, &apos;ess&apos;, &apos;f_pvalue&apos;, &apos;f_test&apos;, &apos;fittedvalues&apos;, &apos;fvalue&apos;, &apos;get_influence&apos;, &apos;get_prediction&apos;, &apos;get_robustcov_results&apos;, &apos;initialize&apos;, &apos;k_constant&apos;, &apos;llf&apos;, &apos;load&apos;, &apos;model&apos;, &apos;mse_model&apos;, &apos;mse_resid&apos;, &apos;mse_total&apos;, &apos;nobs&apos;, &apos;normalized_cov_params&apos;, &apos;outlier_test&apos;, &apos;params&apos;, &apos;predict&apos;, &apos;pvalues&apos;, &apos;remove_data&apos;, &apos;resid&apos;, &apos;resid_pearson&apos;, &apos;rsquared&apos;, &apos;rsquared_adj&apos;, &apos;save&apos;, &apos;scale&apos;, &apos;ssr&apos;, &apos;summary&apos;, &apos;summary2&apos;, &apos;t_test&apos;, &apos;tvalues&apos;, &apos;uncentered_tss&apos;, &apos;use_t&apos;, &apos;wald_test&apos;, &apos;wald_test_terms&apos;, &apos;wresid&apos;] Coefficients: Intercept 55.762750 alcohol 0.267030 chlorides -0.483714 citric_acid -0.109657 density -54.966942 fixed_acidity 0.067684 free_sulfur_dioxide 0.005970 pH 0.439296 residual_sugar 0.043559 sulphates 0.768252 total_sulfur_dioxide -0.002481 volatile_acidity -1.327892 dtype: float64 Coefficient Std Errors: Intercept 11.893899 alcohol 0.016728 chlorides 0.332683 citric_acid 0.079619 density 12.137473 fixed_acidity 0.015573 free_sulfur_dioxide 0.000751 pH 0.090371 residual_sugar 0.005156 sulphates 0.076123 total_sulfur_dioxide 0.000277 volatile_acidity 0.077373 dtype: float64 Adj. R-squared: 0.29 F-statistic: 243.3 P-value: 0.00 Number of obs: 6497 Number of fitted values: 6497 5.自变量标准化 这里尝试使用pandas包在数据框中对变量进行标准化，首先创建了一个名为dependent_variable的序列来保存质量数据，以及创建了一个名为independent_variables的数据框来保存初始的葡萄酒数据集中除quality、type和in_sample之外的所有变量。接着，对每个变量，在每个观测中减去变量的均值，并且使用结果除以变量的标准差，以对其进行标准化。然后将因变量quality作为一列添加到自变量数据框中，并创建一个带有标准化自变量的新数据集wine_standardized。最后再次进行线性回归，并查看一下摘要统计： 123456789101112dependent_variable = wine['quality']independent_variables = wine[wine.columns.difference(['quality', 'type',\\'in_sample'])]independent_variables_standardized = (independent_variables -\\independent_variables.mean()) / independent_variables.std()wine_standardized = pd.concat([dependent_variable, independent_variables\\_standardized], axis=1)lm_standardized = ols(my_formula, data=wine_standardized).fit()print(lm_standardized.summary()) OLS Regression Results ============================================================================== Dep. Variable: quality R-squared: 0.292 Model: OLS Adj. R-squared: 0.291 Method: Least Squares F-statistic: 243.3 Date: Thu, 09 Nov 2017 Prob (F-statistic): 0.00 Time: 08:36:32 Log-Likelihood: -7215.5 No. Observations: 6497 AIC: 1.445e+04 Df Residuals: 6485 BIC: 1.454e+04 Df Model: 11 Covariance Type: nonrobust ======================================================================================== coef std err t P&gt;|t| [0.025 0.975] ---------------------------------------------------------------------------------------- Intercept 5.8184 0.009 637.785 0.000 5.800 5.836 alcohol 0.3185 0.020 15.963 0.000 0.279 0.358 chlorides -0.0169 0.012 -1.454 0.146 -0.040 0.006 citric_acid -0.0159 0.012 -1.377 0.168 -0.039 0.007 density -0.1648 0.036 -4.529 0.000 -0.236 -0.093 fixed_acidity 0.0877 0.020 4.346 0.000 0.048 0.127 free_sulfur_dioxide 0.1060 0.013 7.948 0.000 0.080 0.132 pH 0.0706 0.015 4.861 0.000 0.042 0.099 residual_sugar 0.2072 0.025 8.449 0.000 0.159 0.255 sulphates 0.1143 0.011 10.092 0.000 0.092 0.137 total_sulfur_dioxide -0.1402 0.016 -8.969 0.000 -0.171 -0.110 volatile_acidity -0.2186 0.013 -17.162 0.000 -0.244 -0.194 ============================================================================== Omnibus: 144.075 Durbin-Watson: 1.646 Prob(Omnibus): 0.000 Jarque-Bera (JB): 324.712 Skew: -0.006 Prob(JB): 3.09e-71 Kurtosis: 4.095 Cond. No. 9.61 ============================================================================== 6.预测 在某些情况下，我们需要使用没有用来拟合模型的新数据进行预测。例如，你会收到关于葡萄酒成分的一个新观测，并需要根据这些成分预测这种葡萄酒的质量评分。下面使用葡萄酒数据集中的前10个观测创建10个“新”观测（只包含模型中使用的自变量），接着基于新观测中的葡萄酒特性预测质量评分，并将预测值打印到屏幕上。 12345new_observations = wine.ix[wine.index.isin(range(10)), \\independent_variables.columns]y_predicted = lm.predict(new_observations)y_predicted_rounded = [round(score, 2) for score in y_predicted]print(y_predicted_rounded) [5.0, 4.92, 5.03, 5.68, 5.0, 5.04, 5.02, 5.30, 5.24, 5.69]","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python数据分析","slug":"人生苦短，我用Python/Python数据分析","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python数据分析/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"},{"name":"牛刀小试","slug":"牛刀小试","permalink":"http://gaiusyao.cn/tags/牛刀小试/"}]},{"title":"Python基础06：类","slug":"class","date":"2017-10-30T05:53:27.000Z","updated":"2018-01-10T05:30:34.989Z","comments":true,"path":"2017/10/30/class/","link":"","permalink":"http://gaiusyao.cn/2017/10/30/class/","excerpt":"","text":"面向对象编程是最有效的软件编写方法之一。而理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。在面向对象编程中，需要编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。 创建和使用类创建Dog类 使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类Dog——它表示的不是特定的小狗，而是任何小狗。根据Dog类创建的每个实例都将存储名字和年龄，且赋予了每条小狗蹲下（sit()）和打滚（roll_over()）的能力：123456789101112131415class Dog(): \"\"\"一次模拟小狗的简单尝试\"\"\" def __init__(self, name, age): \"\"\"初始化属性name和age\"\"\" self.name = name self.age = age def sit(self): \"\"\"模拟小狗被命令时蹲下\"\"\" print(\"&#123;0&#125; is now sitting.\".format(self.name.title())) def roll_over(self): \"\"\"模拟小狗被命令时打滚\"\"\" print(\"&#123;0&#125; rolled over!\".format(self.name.title())) 在第1行，定义了一个名为Dog（注意首字母需大写）的类。第2行，按惯例是一个文档字符串。再下面则是三个方法（类中的函数称为方法）。其中方法__init__()是一个特殊的方法，每当根据Dog类创建新实例时，Python都会自动运行它，而__init__()中有一个特殊的形参self，是一个指向实例本身的引用，让实例能够访问类中的属性和方法。而sit()和roll_over()两个方法则负责实现小狗蹲下和打滚动作，由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self。 根据类创建实例 根据类来创建对象被称为实例化，下面根据Dog类来创建一个表示特定小狗的实例：12345678my_dog = Dog('willie', 6)print(\"My dog's name is &#123;0&#125;.\".format(my_dog.name.title()))print(\"My dog is &#123;0&#125; years old.\".format(str(my_dog.age)))my_dog.sit()# My dog's name is Willie.# My dog is 6 years old.# Willie is now sitting. 使用类和实例Car类 下面来编写一个表示汽车的类，它存储了有关汽车的信息，还有一个汇总这些信息的方法：1234567891011121314151617class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year def get_descriptive_name(self): \"\"\"返回整洁的描述性信息\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title()my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name()) # 2016 Audi A4 给属性指定默认值 类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法init()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。下面来添加一个名为odometer_reading的属性，其初始值总是为0。我们还添加了一个名为read_odometer()的方法，用于读取汽车的里程表：123456789101112131415161718192021222324class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\"返回整洁的描述性信息\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\"打印一条指出汽车里程的消息\"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\")my_new_car = Car('audi', 'a4', 2016)print(my_new_car.get_descriptive_name())my_new_car.read_odometer() # 2016 Audi A4# This car has 0 miles on it. 修改属性值 可以以三种不同的方式修改属性的值，下面以修改odometer_reading的值为例： 直接通过实例进行修改：my_new_car.odometer_reading = 23； 通过方法进行设置： 123def update_odometer(self, mileage): \"\"\"将里程表读数设置为指定的值\"\"\" self.odometer_reading = mileage 通过方法进行递增（增加特定的值）： 123def increment_odometer(self, miles): \"\"\"将里程表读数增加指定的量\"\"\" self.odometer_reading += miles 继承继承简介 编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。当然，一个语言如果没有支持继承特性不值得称作“类”。子类定义的语法如下所示：123456class DerivedClassName(BaseClassName): &lt;statement-1&gt; . . . &lt;statement-N&gt; 子类的方法init() 创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法init()需要父类施以援手。下面以Car的子类ElectricCar为例：1234567891011121314151617181920212223242526272829303132333435363738class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\"返回整洁的描述性信息\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\"打印一条指出汽车里程的消息\"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): self.odometer_reading += milesclass ElectricCar(Car): \"\"\"电动汽车的独特之处\"\"\" def __init__(self, make, model, year): \"\"\"初始化父类的属性\"\"\" super().__init__(make, model, year)my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name()) # 2016 Tesla Model S 这里有几点需要注意的：首先是创建子类时，父类必须包含在当前文件中，且位于子类前面。其次。定义子类时，必须在括号内指定父类的名称。方法init()接受创建Car实例所需的信息。而super().__init__(make, model, year)的super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法init()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。 给子类定义属性和方法 让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。下面来添加一个电动汽车特有的属性（电瓶），以及一个描述该属性的方法。我们将存储电瓶容量，并编写一个打印电瓶描述的方法：1234567891011121314151617class ElectricCar(Car): \"\"\"电动汽车的独特之处\"\"\" def __init__(self, make, model, year): \"\"\"初始化父类的属性，再初始化电动汽车特有的属性\"\"\" super().__init__(make, model, year) self.battery_size = 70 def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\")my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.describe_battery()# 2016 Tesla Model S# This car has a 70-kWh battery. 重写父类的方法 对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。 将实例用作属性 使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。我们将存储电瓶容量，并编写一个打印电瓶描述的方法：123456789101112131415161718192021222324252627class Battery(): \"\"\"一次模拟电动汽车电瓶的简单尝试\"\"\" def __init__(self, battery_size=70): \"\"\"初始化电瓶的属性\"\"\" self.battery_size = battery_size def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\")class ElectricCar(Car): \"\"\"电动汽车的独特之处\"\"\" def __init__(self, make, model, year): \"\"\"初始化父类的属性，再初始化电动汽车特有的属性\"\"\" super().__init__(make, model, year) self.battery = Battery() def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\")my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name())my_tesla.battery.describe_battery()# 2016 Tesla Model S# This car has a 70-kWh battery. 导入类 导入单个类：from module_name import ClassName 导入多个类：from module_name import ClassZero, ClassOne 导入所有类：from module_name import * 导入整个模块：import module_name Pytho标准库 Python标准库是一组模块，安装的Python都包含它。在程序开头包含一条简单的import语句，即可使用标准库中的任何函数和类。例如通过from collections import OrderedDict导入模块collections中的OrderedDict类，以创建记录了键—值对的添加顺序的字典：1234567891011from collections import OrderedDictfavorite_languages = OrderedDict()favorite_languages['jen'] = 'python'favorite_languages['sarah'] = 'c'favorite_languages['edward'] = 'ruby'favorite_languages['phil'] = 'python'for name, language in favorite_languages.items(): print(\"&#123;0&#125;'s favorite language is &#123;1&#125;.\".format(name.title(), language.title())) 编写类注意事项 类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，其余小写，且不使用下划线； 实例名和模块名都采用小写格式，并在单词之间加上下划线； 类定义后面需包含一个文档字符串，简要地描述类的功能； 在类中使用一个空行来分隔方法，而在模块中则使用两个空行来分隔类； 用空行分隔导入标准库中的模块和自己编写的模块。 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"Python基础05：函数","slug":"functions","date":"2017-10-30T03:03:45.000Z","updated":"2018-01-10T05:31:04.641Z","comments":true,"path":"2017/10/30/functions/","link":"","permalink":"http://gaiusyao.cn/2017/10/30/functions/","excerpt":"","text":"可以将函数理解为带名字的代码块，用于被反复调用以完成具体的工作。函数的使用，极大地减少了重复代码的出现，提升了代码的可复用性，让程序的编写、阅读、测试和修复都变得更容易。 函数的定义示例 通过关键字def引入函数的定义。它必须后跟函数名和形式参数的括号列表。形成函数体的语句从下一行开始，必须缩进。下面定义了一个函数，用以将Fibonacci序列写入任意边界：123456def fib(n): \"\"\"打印一个Fibonacci序列\"\"\" a, b = 0, 1 while a &lt; n: print(a, end = ' ') a, b = b, a+b 第1行代码是函数定义，向Python指出了函数名，还可能在括号内指出函数为完成其任务需要什么样的信息。第2行的文本是被称为文档字符串（docstring）的注释，描述了函数是做什么的，由三引号括起，Python使用它来生成有关程序中函数的文档。第3至第6行则是具体的执行代码，负责打印一个Fibonacci序列。 向函数传递信息 通过在定义函数fib()添加一个变量n，就可让函数接受你给n指定的任何值，使得调用fib(n)时可以给n指定一个值，从而生成相应的输出，下面的代码将会打印一个Fibonacci序列：12fib(2000)#0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 实参和形参 在前面定义的函数fib()中，变量n是一个形参——函数完成其工作所需的一项信息。在代码fib(2000)中，值2000是一个实参——调用函数时传递给函数的信息。在fib(2000)中，将实参2000传递给了函数fib()，这个值被存储在形参n中，由此得到想要的结果。 传递实参位置实参 在调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。下面是一个显示宠物信息的函数,这个函数指出一个宠物属于哪种动物以及它叫什么名字，在调用它时，需要按顺序提供位置实参数（一种动物类型和一个名字），如下所示：12345678def describe_pet(animal_type, pet_name): \"\"\"显示宠物的信息\"\"\" print(\"I have a &#123;0&#125;.\".format(animal_type)) print(\"My &#123;0&#125;'s name is &#123;1&#125;.\".format(animal_type, pet_name.title())) describe_pet('hamster', 'harry') # I have a hamster.# My hamster's name is Harry. 关键字实参 关键字实参是传递给函数的名称—值对，直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。重写5.2.1的代码，使用关键字实参来调用describe_pet()：123describe_pet(pet_name='harry', animal_type='hamster')# I have a hamster.# My hamster's name is Harry. 默认值 编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。重写5.2.1的代码，形参animal_type的默认值设置为&#39;dog&#39;：1234567def describe_pet(pet_name, animal_type='dog'): \"\"\"显示宠物的信息\"\"\" print(\"I have a &#123;0&#125;.\".format(animal_type)) print(\"My &#123;0&#125;'s name is &#123;1&#125;.\".format(animal_type, pet_name.title()))describe_pet(pet_name='willie')# I have a dog.# My hamster's name is Willie. 上述三种调用方式基本等效，因此使用哪种无关紧要，只要函数调用能生成你希望的输出就行。但要注意避免实参不匹配错误，即提供的实参多于或少于函数完成其工作所需的信息。 返回值返回简单值 下面来看一个函数，它接受名和姓两个参数，并返回一个简单值（一个整洁的姓名）：1234567def get_formatted_name(first_name, last_name): \"\"\"返回整洁的姓名\"\"\" full_name = first_name + ' ' + last_name return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)# Jimi Hendrix 可选实参 有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。例如，假设我们要扩展5.3.1的函数get_formatted_name()，使其还能处理中间名（如果有）。为此，可将中间名放在最后，且默认为空，修改后如下所示：12345678910111213def get_formatted_name(first_name, last_name, middle_name=''): \"\"\"返回整洁的姓名\"\"\" if middle_name: full_name = first_name + ' ' + middle_name + ' ' + last_name else: full_name = first_name + ' ' + last_name return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)# Jimi Hendrixmusician = get_formatted_name('john', 'lee', 'hooker')print(musician)# John Hooker Lee 返回字典 函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典：1234567def build_person(first_name, last_name): \"\"\"返回一个字典，其中包含有关一个人的信息\"\"\" person = &#123;'first': first_name, 'last': last_name&#125; return personmusician = build_person('jimi', 'hendrix')print(musician) 结合while循环 结合while循环，以更正规的方式问候用户，直到用户输入的姓或名为’q’为止：12345678910111213141516171819202122def get_formatted_name(first_name, last_name, middle_name=''): \"\"\"返回整洁的姓名\"\"\" if middle_name: full_name = first_name + ' ' + middle_name + ' ' + last_name else: full_name = first_name + ' ' + last_name return full_name.title()while True: print(\"\\nPlease tell me your name:\") print(\"(enter 'q' at any time to quit)\") f_name = input(\"First name: \") if f_name == 'q': break l_name = input(\"Last name: \") if l_name == 'q': break formatted_name = get_formatted_name(f_name, l_name) print(\"\\nHello, \" + formatted_name + \"!\") 传递列表 向函数传递列表非常有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。下面的示例将一个名字列表传递给一个名为greet_users()的函数，这个函数问候列表中的每个人：12345678910def greet_users(names): \"\"\"向列表中的每位用户都发出简单的问候\"\"\" for name in names: print(\"Hello, &#123;0&#125;!\".format(name.title()))usernames = ['hannah', 'ty', 'margot']greet_users(usernames)# Hello, Hannah!# Hello, Ty!# Hello, Margot! 传递任意数量的实参 有时候，预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。下面的函数包含了两个形参，其中第二个形参*toppings中的*让Python创建一个名为toppings的空元组，但不管调用语句为第二个形参提供了多少实参，*toppings都将它们统统收入囊中：12345678def make_pizza(size, *toppings): \"\"\"概述要制作的比萨\"\"\" print(\"\\nMaking a &#123;0&#125;-inch pizza with the following toppings:\".format(str(size))) for topping in toppings: print(\"- &#123;0&#125;\".format(topping))make_pizza(16, 'pepperoni')make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') 有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。在下面的示例中，函数build_profile()接受名和姓，同时还接受任意数量的关键字实参。其中，**user_info创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中:123456789101112def build_profile(first, last, **user_info): \"\"\"创建一个字典，其中包含我们知道的有关用户的一切\"\"\" profile = &#123;&#125; profile['first_name'] = first profile['last_name'] = last for key, value in user_info.items(): profile[key] = value return profileuser_profile = build_profile('albert', 'einstein', location='princeton', field='physics')print(user_profile) 将函数存储在模块中 函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。导入方式主要有以下几种： 导入整个模块：import module_name 导入模块中所有函数：from module_name import * 导入特定的函数：from module_name import function_0, function_1, function_2 此外，可以通过as语句为导入的模块或函数命名： 为导入模块命名：import module_name as mn 为导入函数命名：from module_name import function_name as fn 函数编写注意事项 编写函数时，需要牢记几个细节： 应给函数指定描述性名称，且只在其中使用小写字母和下划线； 每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式； 给形参指定默认值时，等号两边不要有空格：def function_name(parameter_0, parameter_1=&#39;default value&#39;)； 对于函数调用中的关键字实参，也应遵循这种约定：function_name(value_0, parameter_1=&#39;value&#39;)； 所有的import语句都应放在文件开头的文档注释后。 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"Python基础04：控制流","slug":"control-flow","date":"2017-10-29T02:17:07.000Z","updated":"2018-01-10T05:30:16.861Z","comments":true,"path":"2017/10/29/control-flow/","link":"","permalink":"http://gaiusyao.cn/2017/10/29/control-flow/","excerpt":"","text":"目前为止，除了简单地使用过if语句和for循环以外，Python都是按从上到下的顺序执行语句。如果想要让程序根据不同的情况做不同的事情，例如根据条件执行语句或循环语句，则需要用到控制流。这里介绍三种常见的控制流语句————if、for和while。 条件测试一个if语句的简单示例 下面是一个简短的示例，演示了如何使用if语句来正确地处理特殊情况：12345678avengers = ['iron man', 'captain america', 'hulk', 'thor']print(\"Output #1: \")for avenger in avengers: if avenger == 'iron man': print(\"\\t&#123;0&#125; is very rich.\".format(avenger.title())) else: print(\"\\t&#123;0&#125; has no money.\".format(avenger.title())) 在这个示例中，循环首先检查当前的复仇者是否&#39;iron man&#39;，如果是，则打印if下的相应语句，否则则执行else下的语句。从中我们可以看到，每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。如果条件测试的值为True，Python就执行紧跟在if语句后面的代码；如果为False，Python就忽略这些代码。 检查是否相等 大多数条件测试都将一个变量的当前值同特定值进行比较。最简单的条件测试检查变量的值是否与特定值相等：123iron_man = 'tony stark'iron_man == 'tony stark' #相等，返回Trueiron_man == 'bruce wayne' #不等，返回False 检查是否相等时区分大小写 在Python中检查是否相等时区分大小写，例如，两个大小写不同的值会被视为不相等：12iron_man = 'Tony Stark'iron_man == 'tony stark' #不等，返回False 但如果大小写无关紧要，而只想检查变量的值，可借助前面用到过的lower()将变量的值转换为小写，再进行比较。 检查是否不相等 要判断两个值是否不等，可结合使用惊叹号和等号!=，其中的惊叹号表示不，在很多其他的编程语言中都如此：123requested_topping = 'mushrooms'if requested_topping != 'anchovies': print(\"\\nOutput #2: Hold the anchovies!\") 检查数值 检查数值非常简单，例如，下面的代码检查答案是否是42：123answer = 13if answer != 42: print(\"\\nOutput #3: That is not the ultlimate answer!!!\") 条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于：12345answer = 42answer &lt; 69 #Trueanswer &gt; 69 #Falseanswer &gt;= 30 #Trueanswer &lt;= 83 #True 检查多个条件 有的时候同时检查多个条件，例如，有时候你需要在两个条件都为True时才执行相应的操作，而有时候你只要求其中一个条件为True时就执行相应的操作。在这些情况下，关键字and和or可助你一臂之力：1234age_0 = 22age_1 = 18age_0 &gt;= 21 and age_1 &gt;= 21 #Falseage_0 &gt;= 21 or age_1 &gt;= 21 #True 检查特定值是否包含在列表中 有时候，执行操作前必须检查列表是否包含特定的值。要判断特定的值是否已包含在列表中，可使用关键字in。来看为比萨店编写的一些代码；这些代码首先创建一个列表，其中包含用户点的比萨配料，然后检查特定的配料是否包含在该列表中：123requested_toppings = ['mushrooms', 'onions', 'pineapple']'mushrooms' in requested_toppings #True'pepperoni' in requested_toppings #False 检查特定值是否不包含在列表中 还有些时候，确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字not in：1234banned_users = ['andrew', 'carolina', 'david']user = 'marie'if user not in banned_users: print(\"\\nOutput #4: &#123;0&#125;, you can post a response if you wish.\".format(user.title())) 布尔表达式 布尔表达式，它不过是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为True，要么为False。；布尔值通常用于记录条件，如用户是否有相关权限：1can_edit = False if语句if语句简介 正如前面看到的，if语句用来检验一个条件，常与else从句搭配使用，如果条件测试结果为真(True)，我们运行一块语句(if代码块)，否则，我们处理另外一块语句(else代码块)。其中，else从句是可选的，将在下一部分介绍。 最简单的if语句只有一个测试和一个操作：12if conditional_test: do somethingcan_edit = False 假设有一个表示某人年龄的变量，而你想知道这个人是否够驾驶的年龄，可使用如下代码：123age = 19if age &gt;= 18: print(\"\\nOutput #5: You are old enough to drive!\") if-else语句 经常需要在条件测试通过了时执行一个操作，并在没有通过时执行另一个操作；在这种情况下，就要用到if-else语句。 下面的代码在一个人够驾驶的年龄时显示与前面相同的消息，同时在这个人不够驾驶的年龄时也显示一条消息：12345age = 16if age &gt;= 18: print(\"\\nOutput #6: You are old enough to drive!\")else: print(\"\\nOutput #6: Sorry, you are too young to drive.\") if-elif-else结构 当需要检查的条件超过两个的时候，if-else就明显不够用了，此时就需要借助if-elif-else结构，它依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python将执行紧跟在它后面的代码，并跳过余下的测试，如下例所示：1234567age = 91if age &gt;= 18 and age &lt; 70: print(\"\\nOutput #7: You are old enough to drive!\")elif age &gt;= 70: print(\"\\nOutput #7: Sorry, you are too old to drive.\")else: print(\"\\nOutput #7: Sorry, you are too young to drive.\") 可根据需要使用任意数量的elif代码块，另外也可以省略else代码块，代之以用一条elif语句来处理。 测试多个条件 if-elif-else结构功能强大，但仅适合用于只有一个条件满足的情况：遇到通过了的测试后，Python就跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含elif和else代码块的简单if语句。在可能有多个条件为True，且你需要在每个条件为True时都采取相应措施时，适合使用这种方法。下面再来看前面的比萨店示例。如果顾客点了两种配料，就需要确保在其比萨中包含这些配料：12345678910requested_toppings = ['mushrooms', 'extra cheese']print(\"\\nOutput #8: \")if 'mushrooms' in requested_toppings: print(\"\\tAdding mushrooms.\")if 'pepperoni' in requested_toppings: print(\"\\tAdding pepperoni.\")if 'extra cheese' in requested_toppings: print(\"\\tAdding extra cheese.\")print(\"Finished making your pizza!\") 使用if语句处理列表 可以用if语句检查列表中的特殊值，例如比萨店的青椒用完了，需要检查顾客点的是否是青椒，如果是，就打印一条消息，说明不能点青椒的原因。可在for循环中包含一条if语句完成上述工作：123456789requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']print(\"\\nOutput #9: \")for requested_topping in requested_toppings: if requested_topping == 'green peppers': print(\"\\tSorry, we are out of green peppers right now.\") else: print(\"\\tAdding &#123;0&#125;.\".format(requested_topping))print(\"Finished making your pizza!\") 同样的，可以利用if语句检查列表是否为空：123456789requested_toppings = []print(\"\\nOutput #10: \")if requested_toppings: for requested_topping in requested_toppings: print(\"\\tAdding &#123;0&#125;.\".format(requested_topping)) print(\"Finished making your pizza!\")else: print(\"Are you sure you want a plain pizza?\") 事实上，我们经常需要同时使用多个列表，这会让结构变得稍微复杂一点：12345678910111213available_toppings = ['mushrooms', 'olives', 'green peppers', 'pepperoni', 'pineapple', 'extra cheese']requested_toppings = ['mushrooms', 'french fries', 'extra cheese']print(\"\\nOutput #11: \")if requested_toppings: for requested_topping in requested_toppings: if requested_topping in available_toppings: print(\"\\tAdding &#123;0&#125;.\".format(requested_topping)) else: print(\"\\tSorry, we don't have &#123;0&#125;.\".format(requested_topping)) print(\"Finished making your pizza!\")else: print(\"Are you sure you want a plain pizza?\") for循环for循环详解 在02.列表和元组我们第一次使用了for循环：1234ninja_turtles = ['Leonardo', 'Raphael', 'Michelangelo', 'Donatello']print(\"\\nOutput #12: \")for ninja_turtle in ninja_turtles: print(ninja_turtle) 在上面代码构建的简单循环中，Python将首先读取其中的第一行代码for ninja_turtle in ninja_turtles: 这行代码让Python获取列表ninja_turtles中的第一个值（&#39;Leonardo&#39;），并将其存储到变量ninja_turtle中。接下来，Python读取下一行代码print(ninja_turtle)，它让Python打印ninja_turtle的值——依然是&#39;Leonardo&#39;。 由于列表还包含着其他值，Python返回到循环的第一行for ninja_turtle in ninja_turtles: Python再次打印ninja_turtle的值——这次是&#39;Raphael&#39;。接下来，Python继续前面的步骤，直到将列表中的最后一个值&#39;Donatello&#39;打印出来为止。而此时，列表中已经没有其他的值了，因此Python接着执行程序的下一行代码。 对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python就重复执行指定的步骤一百万次，且通常速度非常快。另外，对于用于存储列表中每个值的临时变量，可指定任何名称，但使用有意义的名称可以提高代码的可读性。 执行更多的操作 在for循环中，可对每个元素执行任何操作，也可以在for循环结束后提供总结性输出或接着执行程序必须完成的其他任务。扩展之前的示例，对每位神龟都打印一条信息，指出他是一个忍者，并在最后指出他们的身份：12345ninja_turtles = ['Leonardo', 'Raphael', 'Michelangelo', 'Donatello']print(\"\\nOutput #13: \")for ninja_turtle in ninja_turtles: print(\"&#123;0&#125; is a ninja.\".format(ninja_turtle))print(\"They\\'re Ninja Turtles!\") while循环input()函数 在介绍while循环前，先让我们花几分钟，了解下input()函数。 input()可以让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。下面的代码将会存储你输入的信息到message，并通过print(message)打印出来：12message = input(\"Tell me something, and I will repeat it back to you: \")print(message) 可以通过input()获取用户的数值输入，但需要注意的是，Python将用户通过input()输入的值解读为字符串，这在将输入作为数字使用时，会引发错误：123456age = input(\"How old are you? \")age #'42'age &gt;= 18Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unorderable types: str() &gt;= int() 这里需要借助int()函数将数字的字符串表示转换为数值表示，如下所示：12age = int(age)age &gt;= 18 #True while循环简介 for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条件不满足为止。下面是一个while循环的简单示例，它将从1数到5：12345current_number = 1print(\"\\nOutput #14: \")while current_number &lt;= 5: print(current_number) current_number += 1 在第1行，我们将current_number设置为1，从而指定从1开始数。接下来的while循环被设成这样：只要current_number小于或等于5，就接着运行这个循环。循环中的代码打印current_number的值，再使用代码current_number += 1（current_number = current_number + 1的简写）将其值加1。只要满足条件current_number &lt;= 5，Python就接着运行这个循环。直到current_number大于5，循环将停止，整个程序也将到此结束。 让用户选择何时退出 可以让用户输入一个退出值（如&#39;quit&#39;），以选择何时退出循环：1234567prompt = \"Tell me something, and I will repeat it back to you:\"prompt += \"\\nEnter 'quit' to end the program. \"message = \"\"print(\"\\nOutput #15: \")while message != 'quit': message = input(prompt) print(message) 使用标志 在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为标志，充当了程序的交通信号灯。记得在条件测试提到的布伦表达式么？可以通过将布伦表达式作为标志。在标志为True时继续运行，并在任何事件导致标志的值为False时让程序停止运行。这样，在while语句中就只需检查一个条件——标志的当前值是否为True:123456789active = Trueprint(\"\\nOutput #16: \")while active: message = input(prompt) if message == 'quit': active = False else: print(message) break和continuebreak语句 break语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。如在while循环中，想要立即退出，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句:12345678print(\"\\nOutput #17: \")while True: city = input(prompt) if city == 'quit': break else: print(\"I'd love to go to &#123;0&#125;!\".format(city.title())) 以while True打头的循环（见）将不断运行，直到遇到break语句。这个程序中的循环不断输入用户到过的城市的名字，直到输入&#39;quit&#39;为止。用户输入&#39;quit&#39;后，将执行break语句，导致Python退出循环。 continue语句 要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。例如，来看一个从1数到10，但只打印其中奇数的循环：12345678current_number = 0print(\"\\nOutput #18: \")while current_number &lt; 10: current_number += 1 if current_number % 2 == 0: continue print(current_number) 首先将current_number设置成了0，由于它小于10，进入while循环。进入循环后，我们以步长1的方式往上数，因此current_number为1。接下来，if语句检查current_number与2的求模运算结果。如果结果为0（意味着current_number可被2整除），就执行continue语句，让Python忽略余下的代码，并返回到循环的开头。如果当前的数字不能被2整除，就执行循环中余下的代码，Python将这个数字打印出来。 避免无限循环 每个while循环都必须有停止运行的途径，这样才不会没完没了地执行下去。例如，下面的循环将会无限循环：123x = 1while x &lt;= 5: print(x) 如果在测试中程序陷入无限循环，可按Ctrl + C，也可关闭显示程序输出的终端窗口。但在实际应用中出现无限循环，则会带来很大的麻烦，因此务必对每个while循环进行测试，确保它按预期那样结束，避免无限循环的出现。 使用while 循环来处理列表和字典在列表之间移动元素 假设有一个列表，其中包含新注册但还未验证的网站用户；验证这些用户后，如何将他们移到另一个已验证用户列表中呢？一种办法是使用一个while循环，在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中。代码可能类似于下面这样：1234567891011121314151617# 首先，创建一个待验证用户列表和一个用于存储已验证用户的空列表unconfirmed_users = ['alice', 'brian', 'candace']confirmed_users = []print(\"\\nOutput #19: \")# 验证每个用户，直到没有未验证用户为止# 将每个经过验证的列表都移到已验证用户列表中while unconfirmed_users: current_user = unconfirmed_users.pop() print(\"Verifying user: &#123;0&#125;\".format(current_user.title())) confirmed_users.append(current_user)# 显示所有已验证的用户print(\"The following users have been confirmed:\")for confirmed_user in confirmed_users: print(\"\\t&#123;0&#125;\".format(confirmed_user.title())) 删除包含特定值的所有列表元素 在02.列表和元组，我们使用remove()函数来删除列表中的特定值。而结合while循环，可以删除列表中所有包含特定值的元素：12345678# 创建一个宠物列表，其中包含多个值为'cat'的元素pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']print(\"\\nOutput #20 (original): \".format(pets))while 'cat' in pets: pets.remove('cat')print(\"\\nOutput #20 (removed): \".format(pets)) 使用用户输入来填充字典 可使用while循环提示用户输入任意数量的信息，并将收集的数据存储在一个字典中：1234567891011121314151617181920212223# 创建一个空字典responses = &#123;&#125;# 设置一个标志，指出调查是否继续polling_active = Truewhile polling_active: # 提示输入被调查者的名字和回答 name = input(\"\\nWhat is your name? \") response = input(\"Which mountain would you like to climb someday? \") # 将答卷存储在字典中 responses[name] = response # 看看是否还有人要参与调查 repeat = input(\"Would you like to let another person respond? (yes/ no) \") if repeat == 'no': polling_active = False# 调查结束，显示结果print(\"\\nOutput #21: \")for name, response in responses.items(): print(name + \" would like to climb \" + response + \".\") 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"Python基础03：字典","slug":"dictionaries","date":"2017-10-28T13:17:18.000Z","updated":"2018-01-10T05:30:54.966Z","comments":true,"path":"2017/10/28/dictionaries/","link":"","permalink":"http://gaiusyao.cn/2017/10/28/dictionaries/","excerpt":"","text":"字典(Dictionaries)简介 Python中的字典本质上是包含各种带有唯一标识符的成对信息的列表，可以理解为是一系列的键—值对，但与列表不同的是，字典是以键（整数、字符串、列表、字典或其他Python 对象）而非索引来引用某个元素，在唯一键值比连续整数更能反映出变量值含义的情况下，这个特点使字典比列表更实用。另外，字典是由花括号{}括起的，而非列表的中括号[]。而更为关键的是，字典不同于列表，字典是没有内置排序的，而列表会根据索引值（连续整数）进行隐式排序，这让字典可以很方便快速的进行搜索或添加操作（计算机不需要重新分配索引），这也让字典比列表更适合处理数据量多的情况。下面是一个简单的字典示例：12simple_dict = &#123;'one':1, 'two':2, 'three':3&#125;print(\"Output #1: &#123;0&#125;\".format(simple_dict)) #将字典打印出来，包括花括号 使用字典访问字典中的值 要获取与键相关联的值，可依次指定字典名和放在方括号内的键dict_name[key]，如下所示：12ninja_turtle_0 = &#123;'name':'Leonardo', 'color':'blue', 'weapon':'katana'&#125;print(\"Output #2: &#123;0&#125;\".format(ninja_turtle_0['name'])) #Leonardo 添加键—值对 字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。下面为ninja_turtle_0添加两项信息：位置的X坐标和Y坐标。123ninja_turtle_0['x_position'] = 190ninja_turtle_0['y_position'] = 250print(\"Output #3: &#123;0&#125;\".format(ninja_turtle_0)) 先创建一个空字典 使用字典来存储用户提供的数据或在编写能自动生成大量键—值对的代码时，通常都需要先定义一个空字典：1234master_rat = &#123;&#125;master_rat['name'] = \"Splinter\"master_rat['color'] = \"grey\"print(\"Output #4: &#123;0&#125;\".format(master_rat)) 修改字典中的值 要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。例如，修改忍者神龟的位置：123ninja_turtle_0['x_position'] = 250ninja_turtle_0['y_position'] = 200print(\"Output #5: &#123;0&#125;, &#123;1&#125;\".format(ninja_turtle_0['x_position'], ninja_turtle_0['y_position'])) 删除键—值对 对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。这里要注意的是，在使用del语句时，必须指定字典名和要删除的键：12del ninja_turtle_0['weapon']print(\"Output #6: &#123;0&#125;\".format(ninja_turtle_0)) 由类似对象组成的字典 字典存储的是一个对象（忍者神龟里的角色）的多种信息，但你也可以使用字典来存储众多对象的同一种信息。例如，假设你要调查很多人，询问他们最喜欢的编程语言，可使用一个字典来存储这种简单调查的结果，如下所示：1234567favorite_languages = &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python', &#125;print(\"Output #7: \\nSarah's favorite language is \" + favorite_languages['sarah'].title() + \".\") 遍历字典遍历所有的键—值对 使用for循环遍历favorite_languages中的所有键—值对，并逐个打印出每人最喜欢什么编程语言：123print(\"Output #8: \")for key, value in favorite_languages.items(): print(key.title() + \"'s favorite language is \" + value.title() + \".\") 遍历字典中的所有键 在不需要使用字典中的值时，可以利用keys()函数提取字典的键。下面来遍历favorite_languages，并将每个被调查者的名字都打印出来：123print(\"Output #9: \")for name in favorite_languages.keys(): print(name.title()) 按顺序遍历字典中的所有键 字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序。为此，可使用之前用过的sorted()函数来获得按特定顺序排列的键列表的副本：123print(\"Output #10: \")for name in sorted(favorite_languages.keys()): print(\"&#123;0&#125;, thank you for taking the poll.\".format(name.title())) 遍历字典中的所有值 如果你感兴趣的主要是字典包含的值，可使用values()函数，它返回一个值列表，而不包含任何键。例如，如果我们想获得一个列表只包含被调查者选择的各种语言，而不包含被调查者的名字，可以这样做：123print(\"Output #11: \")for language in favorite_languages.values(): print(language.title()) 这里得到的结果会出现两个Python，如果不希望结果中出现重复的元素，可使用集合（set）。集合类似于列表，但每个元素都必须是独一无二的：123print(\"Output #12: \")for language in set(favorite_languages.values()): print(language.title()) 嵌套字典列表 字典ninja_turtle_0中只存储了一个忍者神龟的信息，而需要存储其他忍者神龟的信息，则需要创建一个忍者神龟列表，其中每一个忍者神龟都是一个字典，包含各种相关信息，如下所示：123456789ninja_turtle_0 = &#123;'name':'Leonardo', 'color':'blue', 'weapon':'katana'&#125;ninja_turtle_1 = &#123;'name':'Raphael', 'color':'red', 'weapon':'sai'&#125;ninja_turtle_2 = &#123;'name':'Michelangelo', 'color':'orange', 'weapon':'double-cut stick'&#125;ninja_turtle_3 = &#123;'name':'Donatello', 'color':'purple', 'weapon':'bo'&#125;ninja_turtles = [ninja_turtle_0, ninja_turtle_1, ninja_turtle_2, ninja_turtle_3]print(\"Output #13: \")for ninja_turtle in ninja_turtles: print(ninja_turtle) 完成忍者神龟字典列表的创建后，我们再用range()生成30个脚帮杂兵：12345678910111213#创建一个空列表foot_ninjas = []#创建30个脚帮杂兵for foot_ninja_num in range(30): new_foot_ninja = &#123;'color': 'black', 'weapon':'sword'&#125; foot_ninjas.append(new_foot_ninja)#显示前5个脚帮杂兵的详细信息，和总数print(\"Output #14: \")for foot_ninja in foot_ninjas[:5]: print(foot_ninja)print(\"Total number of foot ninjas: \" + str(len(foot_ninjas))) 这里我们还可以利用切片操作，将一部分脚帮杂兵的武器改为弓箭：12345print(\"Output #15: \")for foot_ninja in foot_ninjas[3:9]: if foot_ninja['weapon'] != 'bow': foot_ninja['weapon'] = 'bow' print(foot_ninja) 在字典中存储列表 有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢？如果使用列表，只能存储要添加的比萨配料；但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。在下面的示例中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键toppings相关联的值:12345678pizza = &#123; 'crust': 'thick', 'toppings': ['mushrooms', 'extra cheese'], &#125;# 概述所点的比萨print(\"Output #16: \\nYou ordered a &#123;0&#125;-crust pizza with the following toppings:\".format(pizza['crust']))for topping in pizza['toppings']: print(\"\\t\" + topping) 每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。在本章前面有关喜欢的编程语言的示例中，如果将每个人的回答都存储在一个列表中，被调查者就可选择多种喜欢的语言:123456789101112favorite_languages = &#123; 'jen': ['python', 'ruby'], 'sarah': ['c'], 'edward': ['ruby', 'go'], 'phil': ['python', 'haskell'], &#125;print(\"Output #17: \")for name, languages in favorite_languages.items(): print(\"\\n&#123;0&#125;'s favorite languages are:\".format(name.title())) for language in languages: print(\"\\t&#123;0&#125;\".format(language.title())) 在字典中存储字典 可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。例如，如果有多个网站用户，每个都有独特的用户名，可在字典中将用户名作为键，然后将每位用户的信息存储在一个字典中，并将该字典作为与用户名相关联的值：12345678910111213141516171819users = &#123; 'aeinstein': &#123; 'first': 'albert', 'last': 'einstein', 'location': 'princeton', &#125;, 'mcurie': &#123; 'first': 'marie', 'last': 'curie', 'location': 'paris', &#125;, &#125;for username, user_info in users.items(): print(\"\\nUsername: &#123;0&#125;\".format(username)) full_name = user_info['first'] + \" \" + user_info['last'] location = user_info['location'] print(\"\\tFull name: &#123;0&#125;\".format(full_name.title())) print(\"\\tLocation: &#123;0&#125;\".format(location.title())) 需要注意的是，这里表示每位用户的字典的结构都相同，这使得嵌套的字典处理起来更容易。倘若表示每位用户的字典都包含不同的键，for循环内部的代码将更复杂。 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"Python基础02：列表和元组","slug":"lists-tuples","date":"2017-10-28T02:42:18.000Z","updated":"2018-01-10T05:33:11.987Z","comments":true,"path":"2017/10/28/lists-tuples/","link":"","permalink":"http://gaiusyao.cn/2017/10/28/lists-tuples/","excerpt":"","text":"序列(Sequence)简介 序列是Python中最基本的数据结构，一组有顺序的元素的集合。序列中的每个元素都分配一个数字指向它的位置，这个数字被称之为索引，第一个索引是0，第二个索引是1，依此类推。 基本序列类型 Python有6个序列的内置类型，但最常见的是列表(lists)和元组(tuples)。其中，列表是由一系列按特定顺序排列的元素组成，用方括号[]来表示列表，并用逗号来分隔其中的元素。下面是一个简单的列表示例：12band = ['Bon Jovi', 'Guns &amp; Roses', 'Radiohead', 'Simple Plan']print(\"Output #1: &#123;0&#125;\".format(band)) #将列表打印出来，包括方括号 列表非常适合用于存储在程序运行期间可能变化的数据集，因为列表是可以修改的，但有的时候，也需要创建一系列不可修改的元素。Python将不能修改的值称为不可变的(immutable)，而不可变的序列被称为元组，下面是一个简单的元组实例：1dimensions = (200, 120) 通用序列操作 大多数序列类型（包括可变序列和不可变序列）都支持下面表个中的操作。 操作 结果 x in s 如果s包含x，返回True，否则返回False x not in s 如果s包含x，返回False，否则返回True s + t s和t的并置 s n or n s 相当于将s添加到自身n次 s[i] s的第i项，从第0项开始 s[i:j] s的从第i项到第j-1项 s[i:j:k] s的从第i项到第j-1项,间隔为k len(s) s的长度 min(s) s的最小项 max(s) s的最大项目 s.index(x [， i [， j]]) 在s中（在索引i之后或索引j之前）的x s.count(x) s中x的总出现次数 列表（Lists）元素访问列表元素 列表是有序集合，因此也可以通过索引访问列表的任何元素，具体形式为list_name[index]。当通过索引访问列表元素时，只返回访问的元素，而不包括方括号和引号：12print(\"Output #2: &#123;0&#125;\".format(band[0])) #列表索引也是从0开始print(\"Output #3: &#123;0&#125;\".format(band[-1])) #同样可以使用负数索引 同样的，列表也可以进行切片操作，且切片操作会返回一个包含所请求元素的新列表，这意味着切片操作将会返回一个此列表的（浅）拷贝：1print(\"Output #4: &#123;0&#125;\".format(band[-3:])) 使用列表中的各个值 可像使用其他变量一样使用列表中的各个值。如可以使用拼接根据列表中的值来创建消息：12message = \"My favorite band is \" + band[0].title() + \"!\"print(\"Output #5: &#123;0&#125;\".format(message)) 运行上面的代码，在Output #4后是message的值，即My favorite band is Bon Jovi！ 添加列表元素 不同于字符串，创建的列表大多数是动态的，这意味着列表创建后，可以随着程序的运行增删改元素。 Python提供了多种在既有列表中添加新数据的方式，最常用的是使用append()函数在列表末尾添加元素，或使用insert()函数将元素插入到指定位置。1234band.append('Zard') #使用append(),将元素附加到列表末尾print(\"Output #6: &#123;0&#125;\".format(band)) band.insert(1, 'Sum 41') #使用insert(),将元素插入到列表中第二个位置print(\"Output #7: &#123;0&#125;\".format(band)) 修改列表元素 修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。例如，将band[1]重新指定为&#39;Sum 42&#39;:12band[1] = \"Sum 42\"print(\"Output #8: &#123;0&#125;\".format(band[1])) 删除列表元素 经常需要删除列表中的一个或多个元素，可根据位置或值来删除列表中的元素，常见的方法有以下四种：1234567891011121314#方法1：使用del语句删除指定位置的元素del band[1] print(\"Output #9: &#123;0&#125;\".format(band)) #方法2：使用pop()删除列表末尾的元素，或者更形象的称之为弹出popped_band = band.pop()print(\"Output #10 (band): &#123;0&#125;\".format(band)) print(\"Output #10 (popped_band): &#123;0&#125;\".format(popped_band)) #方法3：使用pop()来删除列表中指定位置的元素first_band = band.pop(0)print(\"Output #11 (band): &#123;0&#125;\".format(band)) print(\"Output #11 (first_band): &#123;0&#125;\".format(first_band)) #方法4：使用remove()根据元素值删除元素band.remove('Simple Plan')print(\"Output #12 (band): &#123;0&#125;\".format(band)) 对列表进行排序 列表中的元素排列顺序通常是没有规律的，但又经常有以特定顺序呈现信息的需求，因此需要对列表进行排序。最简单的是通过sort()函数对列表进行排序。假设现在有一个汽车列表，并要让其中的汽车按字母顺序排列。为简化这项任务，我们假设该列表中的所有值都是小写的。123cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort()print(\"Output #13: &#123;0&#125;\".format(cars)) sort()永久性地改变了列表元素的排列顺序。现在，汽车是按字母顺序排列的，且再也无法恢复到原来的排列顺序。若想保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用sorted()函数:123cars = ['bmw', 'audi', 'toyota', 'subaru']print(\"Output #14 (sorted): &#123;0&#125;\".format(sorted(cars)))print(\"Output #14 (original): &#123;0&#125;\".format(cars)) 前面都是使用字母顺序排序，若想按与字母顺序相反的顺序显示列表，也可向sort()或sorted()传递参数reverse=True。 反转列表 使用reverse()函数可轻松地反转列表，且可以很方便的恢复，只需要再次调用reverse()即可。1234cars.reverse()print(\"Output #15 (reversed): &#123;0&#125;\".format(cars))cars.reverse()print(\"Output #15 (original): &#123;0&#125;\".format(cars)) 确定列表长度 使用len()函数可快速获悉列表的长度。1print(\"Output #16: &#123;0&#125;\".format(len(cars))) #4 索引错误(IndexError) 使用列表经常易犯索引错误，如下所示：1234Traceback (most recent call last): File \"F:/pivotlab/learn_python/lists.py\", line 57, in &lt;module&gt; band[42]IndexError: list index out of range 索引错误意味着Python无法理解你指定的索引，这时可以尝试将你指定的索引减1，或者索引-1，以检查索引错误是因为多了一位，还是列表为空。 操作列表遍历整个列表 现在假设我们有一个名单，需要将名单中的名字都打印出来。我们可以通过索引分别获取并打印名单中每个名字，但这样会有大量的重复，且每次名单发生变化，都需要修改代码。因此，我们需要使用for循环（将在控制流中深入讨论）去遍历整个列表，逐个打印名单中的名字：1234ninja_turtles = ['Leonardo', 'Raphael', 'Michelangelo', 'Donatello']print(\"Output #17: \")for ninja_turtle in ninja_turtles: print(ninja_turtle) 在for循环中，可对每个元素执行任何操作。下面来扩展前面的示例，对于每位神龟，都打印一条消息，指出他是一个忍者了。1234ninja_turtles = ['Leonardo', 'Raphael', 'Michelangelo', 'Donatello']print(\"Output #18: \")for ninja_turtle in ninja_turtles: print(ninja_turtle.title() + \", is a ninja!\") 创建数值列表 前面的列表存储的均为字符串，但列表也经常用于存储一组数字，下面先用range()函数生成一些数字：123print(\"Output #19: \") for value in range(1,5): print(value) 可以看到，上述代码只打印了数字1~4，而没有包括5，需要打印1~5，则应写成for value in range(1,6)。 接着，我们通过使用list()函数将range()的结果直接转换为列表：123#range()中第1、2个参数分别是起始值，第3个参数为步长，从2开始数，然后不断地加2，直到达到或超过终值（11）numbers = list(range(2,11,2)) print(\"Output #20: &#123;0&#125;\".format(numbers)) 使用函数range()几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数（即1~10）的平方：1234squares = []for square in range(1,11): squares.append(square**2)print(\"Output #21: &#123;0&#125;\".format(squares)) 前面介绍的生成列表squares的方式包含三行代码，而列表解析让你只需编写一行代码就能生成这样的列表。如下列代码所示，列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。12squares = [value**2 for value in range(1,11)]print(\"Output #22: &#123;0&#125;\".format(squares)) 可以利用几个专门用于处理数字列表的Python函数，对列表进行简单的统计计算，例如，你可以轻松地找出数字列表的最大值、最小值和总和：1234digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]print(\"Output #23 (min): &#123;0&#125;\".format(min(digits))) #0print(\"Output #23 (max): &#123;0&#125;\".format(max(digits))) #9print(\"Output #23 (sum): &#123;0&#125;\".format(sum(digits))) #45 使用列表的一部分 在前面介绍访问列表元素的时候，已简单地提到了切片操作，通过切片，可以很方便地使用列表的一部分元素。下面使用切片进行的遍历列表元素和复制列表的示例：12345678players = ['charles', 'martina', 'michael', 'florence', 'eli']print(\"Here are the first three players on my team:\")for player in players[:3]: #遍历切片 print(player.title())other_players = players[3:] #复制列表的剩余部分print(\"Here are the other players on my team:\")for player in other_players [:]: #遍历切片 print(player.title()) 元组(Tuples)定义元组 元组看起来与列表非常相似，但使用的是圆括号()而非方括号[]来标识。定义元组后，就可以像访问列表元素一样使用索引来访问元组元素。下面的代码定义了一个名为dimensions的元组，存储了一个矩形的长度和宽度：123dimensions = (200, 120)print(\"Output #24 (length): &#123;0&#125;\".format(dimensions[0]))print(\"Output #24 (width): &#123;0&#125;\".format(dimensions[1])) 下面来尝试通过dimensions[0] = 250修改元组dimensions中的一个元素，结果将得到一个类型错误(TypeError)：1TypeError: 'tuple' object does not support item assignment 遍历元组 像列表一样，也可以使用for循环来遍历元组中的所有值：12for dimension in dimensions: print(\"Output #25: &#123;0&#125;\".format(dimension)) 修改元组变量 虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：1234dimensions = (400, 100)print(\"\\nModified dimensions:\")for dimension in dimensions: print(dimension) 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"Python基础01：变量和简单数据类型","slug":"numbers-strings","date":"2017-10-26T16:00:00.000Z","updated":"2018-01-10T05:33:24.936Z","comments":true,"path":"2017/10/27/numbers-strings/","link":"","permalink":"http://gaiusyao.cn/2017/10/27/numbers-strings/","excerpt":"","text":"人生苦短，我用Python。 根据GitHub2017开发者年度报告，Python已成为了GitHub上第二受欢迎的语言（第一名是JavaScript）。这从一个侧面反映了Python正越来越被广泛地使用，也许是因为越来越多的开发者明白了“生命的可贵”？ 作为一名会点编程的产品狗，从大二开始接触Python，但除写爬虫以外，基本没用Python做什么正确的事情。目前对使用Python进行数据分析很感兴趣，计划先把Python基础再过一遍，然后尝试使用Python（或许会结合R）进行数据分析的工作。这里介绍一个IDE——Anaconda ,它所提供的包管理和环境管理功能，可以省去不少麻烦，安装配置教程请戳这儿。安装好Python或Anaconda后，就让我们先从Python的变量和简单数据类型开始： // 笔者使用的版本为Python3.6.3 变量 按照惯例，先从Hello World开始，运行下面的代码，将会显示Hello world1print(\"Hello world\") 变量和变量值 下面尝试使用变量来输出Hello world1234hello_world = \"Hello world\"print(hello_world)hello_world = \"Hello Python world\"print(hello_world) 这里，我们首先添加了一个名为hello_world的变量，并给其赋值为&quot;Hello world&quot;，接着，又将变量hello_world的值修改为&quot;Hello Python world&quot;。执行这四行代码，将会先后打印Hello world和Hello Python world。因此，在程序中可随时修改变量的值，而Python将始终记录变量的最新值。 变量的命名和使用 在Python中，变量的命名和使用需要遵循一定的规则，违反这些规则将带来不必要的错误，或使得代码变得难以阅读和理解。因此，请务必牢记并遵循以下规则： 变量名只能包含字母、数值和下划线，且不能以数值打头； 变量名不能包含空格，但可使用下划线来分隔其中的单词； 不要将Python关键字和函数名用作变量名； 变量名应既简短又具有描述性，如greeting_message； 谨慎使用小写字母l和大写字母O，易被误认为是数值1和0; 变量名宜统一使用小写。 另外，请注意不要出现拼写错误（如hello_world拼成了hello_wolrd），因为解释器不会对代码进行拼写检查。一旦出现拼写错误，解释器将会返回一个名称错误（NameError）:1NameError: name 'hello_wolrd' is not defined // 名称错误的出现通常是因为出现拼写错误，或未在使用变量前给其赋值。 数值(Numbers) Python支持4种数值类型： int（整型）：10 long（长整型）：51924361L float（浮点型）：0.0 complex（复数）：3.14j 其中，整型和浮点型应用的最为广泛，下面就重点介绍着两种数值类型。 整型1234x = 42print(\"Output #1: &#123;0&#125;\".format(x))print(\"Output #2: &#123;0&#125;\".format(3**4))print(\"Output #3: &#123;0&#125;\".format(int(8.1)/int(2.7))) Output #1展示了如何将一个整数（数值42）赋给变量x，然后将变量x打印出来。Output #5说明了如何得到3的4次方并将结果打印出来。Output #3演示了将数值转换成整数并进行除法运算的方法。数值通过内置的int函数转换成整数，所以算式变成了8.1除以2.7，结果为3.0。 // format()为格式化函数 浮点型 浮点型即带小数点的数，和整型一样，都是最常用的数值类型，示例如下：123456print(\"Output #4: &#123;0:.3f&#125;\".format(8.1/2.7))y = * 4.8print(\"Output #5: &#123;0:.1f&#125;\".format(y))r = 8 / float(3)print(\"Output #6: &#123;0:.2f&#125;\".format(r))print(\"Output #7: &#123;0:.4f&#125;\".format(8.0/3)) Output #4和Output #6非常相似，除了将两个相除的数保留为浮点数，这样算式就是8.1除以2.7，等于3.000。这个示例中print语句的语法，&quot;{0:.3f}&quot;.format(floating_point_number/floating_point_number)，说明了如何设置print 语句中的小数位数。在这示例中，.3f设定了打印的输出值应该有3位小数。Output #8表示用乘以4.8，将结果赋给变量y，然后将结果打印出来，带有一位小数。这两个浮点数相乘的结果是12，所以打印出的值是12.0。Output #6和Output #7表示以两种方式计算8除以3，结果都是一个浮点数，大约等于2.667。 常用数值操作 操作 结果 x + y 加法运算 x - y 减法运算 x * y 乘法运算 x / y 除法运算 x // y x除以y的商向下取整的整数 x % y 取余运算 -x x取负 +x x没有变化 abs(x) x的绝对值 int(x) 将x转换为整型 float(x) 将x转换为浮点型 complex(re, im) 将参数转换为复数，re为复数的实部，im(默认0)为复数的虚部 c.conjugate() 复数c的共轭 divmod(x, y) (x // y， x % y) pow(x, y) x的y次幂 x ** y x的y次幂 math模块 math是一个十分有用的标准模块，可以满足一些常见的数值计算。需要使用math模块时，只需在脚本开头添加from math import [function name]，如from math import exp, log, sqrt添加了exp、log和sqrt三个函数，即可进行乘方、自然对数和平方根的计算。1234z = 6print(\"Output #8: &#123;0:.4f&#125;\".format(exp(z)))print(\"Output #9: &#123;0:.2f&#125;\".format(log(z)))print(\"Output #10: &#123;0:.1f&#125;\".format(sqrt(z))) Output #8到Output #10分别输出z的乘方、自然对数和平方根，约为403.4288，1.79，2.4。 关于数学模块和其他标准模块以及内置函数的更多信息，可以参考Python3标准库。 字符串(Strings) 字符串就是一系列字符组成的序列，是Python中的另一种基本数据类型。字符串由引号括起，其中的引号可以是单引号，也可以是双引号，甚至是3个单引号或3个双引号。下面是字符串的几个示例：12345678910print(\"Output #11: &#123;0:s&#125;\".format('I\\'m enjoying learning Python.'))print(\"Output #12: &#123;0:s&#125;\".format(\"This is a long string. Without the backslash\\it would run off of the page on the right in the text editor and be very\\difficult to read and edit. By using the backslash you can split the long\\string into smaller strings on separate lines so that the whole string is easy\\to view in the text editor.\"))print(\"Output #13: &#123;0:s&#125;\".format('''You can use triple single quotesfor multi-line comment strings.'''))print(\"Output #14: &#123;0:s&#125;\".format(\"\"\"You can also use triple double quotesfor multi-line comment strings.\"\"\")) 从上面的示例中，我们不难发现，由1个单引号或1个双引号括起的字符串为单行字符串，需要换行的时候，必须在行尾加上\\。但这种办法不够稳妥，因为\\必须是行尾最后一个字符，如果意外地按了一下空格键，\\后面就会出现一个看不见的空格，从而出现语法错误，不能正常运行。而由3个单引号或3个双引号括起的，则为多行字符串，不需要行尾添加\\，这个特性也被人用来创建多行注释（并不建议这样做）。下面是字符串的分片和索引，以及几个常用的字符串函数： 切片和索引 字符串可以用过string[X]来索引(X为一整数)。同时可以通过string[X:Y]（X、Y可以为正负整数或空）来进行切片操作，即从字符串总拿出一部分，储存在另一个地方。下面通过代码示例来简单说明：123456gaius_yao = \"Product Manager\"gaius_yao[0] # 'P'，字符串第一个字符gaius_yao[2] # 'o'，字符串第二个字符gaius_yao[-1] # 'r'，字符串最后一个字符gaius_yao[:7] # 'Product'，字符串前七个字符gaius_yao[-7:] # 'Manager'，字符串后七个字符 split() split()函数将一个字符串拆分成一个子字符串列表，列表中的子字符串正好可以构成原字符串（列表为Python中的另一种数据类型，属于下一篇的内容）。split()函数可以在括号中使用两个附加参数，分别表示使用哪个字符进行拆分合进行拆分的次数。1234567891011string1 = \"My deliverable is due in May\"string1_list1 = string1.split()string1_list2 = string1.split(\" \",2)print(\"Output #15: &#123;0&#125;\".format(string1_list1))print(\"Output #16: FIRST PIECE:&#123;0&#125; SECOND PIECE:&#123;1&#125; THIRD PIECE:&#123;2&#125;\"\\.format(string1_list2[0], string1_list2[1], string1_list2[2]))string2 = \"Your,deliverable,is,due,in,June\"string2_list = string2.split(',')print(\"Output #17: &#123;0&#125;\".format(string2_list))print(\"Output #18: &#123;0&#125; &#123;1&#125; &#123;2&#125;\".format(string2_list[1], string2_list[5],\\string2_list[-1])) Output #15中，括号内无附加参数，因此split()函数按默认值（空格字符）进行拆分，又因为字符串中含有5个空格被拆分为6个子字符串。Output #16则包含了两个附加参数&quot; &quot;和2，即只想使用前两个空格进行拆分，生成含有三个子字符串的列表。Output #17和Output #18的附加参数为,，因此在出现逗号的位置拆分字符串。 join() join()函数与split()函数相反，将列表中的子字符串组合成一个字符串。使用时，将一个参数放在join()面前，表示使用这个字符（或字符串）在子字符串之间进行组合：1print(\"Output #19: &#123;0&#125;\".format(','.join(string2_list))) 结果为Your,deliverable,is,due,in,June。 strip() strip()函数可以从字符串的两侧去除空格、制表符和换行符，而想要仅从字符串地方左侧或右侧去除，则需要用到lstrip()或rstrip()函数。12345678string3 = \" Remove unwanted characters from this string.\\t\\t \\n\"print(\"Output #20: string3: &#123;0:s&#125;\".format(string3))string3_lstrip = string3.lstrip()print(\"Output #21: lstrip: &#123;0:s&#125;\".format(string3_lstrip))string3_rstrip = string3.rstrip()print(\"Output #22: rstrip: &#123;0:s&#125;\".format(string3_rstrip))string3_strip = string3.strip()print(\"Output #23: strip: &#123;0:s&#125;\".format(string3_strip)) strip()函数还可以设置附加参数，以从字符串两端删除其他字符，如Output #25将string4中的&#39;$_-+&#39;字符全部删去。12345string4 = \"$$Here's another string that has unwanted characters.__---++\"print(\"Output #24: &#123;0:s&#125;\".format(string4))string4 = \"$$The unwanted characters have been removed.__---++\"string4_strip = string4.strip('$_-+')print(\"Output #25: &#123;0:s&#125;\".format(string4_strip)) replace() replace()函数将字符串中的一个或一组字符替换为另一个或另一组字符。这个函数在括号中使用两个附加参数，第一个参数是要在字符串中查找替换的字符或一组字符，第二个参数是要用来替换掉第一个参数的字符或一组字符：12345string5 = \"Let's replace the spaces in this sentence with other characters.\"string5_replace = string5.replace(\" \", \"!@!\")print(\"Output #26 (with !@!): &#123;0:s&#125;\".format(string5_replace))string5_replace = string5.replace(\" \", \",\")print(\"Output #27 (with commas): &#123;0:s&#125;\".format(string5_replace)) Output #32展示了如何使用replace()函数将字符串中的空格替换为!@!，而Output #33则展示了如何使用逗号替换字符串中的空格。 lower()、upper()和capitalize() lower()和upper()函数分别用来将字符串中的字母转换成小写或大写，而capitalize()函数则是将字符串中的第一个字母变为大写，其余变为小写。12345678910string6 = \"Here's WHAT Happens WHEN You Use lower.\"print(\"Output #28: &#123;0:s&#125;\".format(string6.lower()))string7 = \"Here's what Happens when You Use UPPER.\"print(\"Output #29: &#123;0:s&#125;\".format(string7.upper()))string5 = \"here's WHAT Happens WHEN you use Capitalize.\"print(\"Output #30: &#123;0:s&#125;\".format(string5.capitalize()))string5_list = string5.split()print(\"Output #31 (on each word):\")for word in string5_list: print(\"&#123;0:s&#125;\".format(word.capitalize())) Output #28和Output #29通过lower()和upper()，将string6中的所有字母变为小写，string7中的所有字母变为大写。Output #30和Output #31则演示了capitalize()，其中`Output #31用到了for循环（在控制流中再详细讨论）将每一个子符串首字母大写。 len() 通过len()函数可以得到字符串的长度，使用方法为len(str)，试运行下方的代码，将会得到终极答案42。12question = \"the answer to life universe and everything\"print(\"The answer is &#123;0&#125;\".format(len(question))) 本篇文章的代码可从我的GitHub上获取。","categories":[{"name":"人生苦短，我用Python","slug":"人生苦短，我用Python","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/"},{"name":"Python基础","slug":"人生苦短，我用Python/Python基础","permalink":"http://gaiusyao.cn/categories/人生苦短，我用Python/Python基础/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://gaiusyao.cn/tags/python3/"}]},{"title":"GTD简介","slug":"gtd-intro","date":"2017-10-20T16:00:00.000Z","updated":"2018-01-10T05:40:22.545Z","comments":true,"path":"2017/10/21/gtd-intro/","link":"","permalink":"http://gaiusyao.cn/2017/10/21/gtd-intro/","excerpt":"","text":"GTD（Getting Things Done）是一套出色的时间管理系统，其核心理念是以下这段话： “把所有事情都从你的脑袋里弄出来。在事情出现就做好相关行动的一系列决定，而不是在事情爆发的时候。以合适的类别组织好你的项目的各种提醒以及下一步行动。保持你的系统更新和完整，及时进行回顾，使你在任何时候都能信任你的系统和对任务的处理。” 可以概括为：通过记录的方式将各种事情从脑海中移出，将其处理、组织后执行并及时复盘。 GTD说起来复杂，却也简单，只有五个核心步骤：收集、处理、组织、复盘、执行。 1.五步开始GTD1.1 收集 把任何需要跟踪、记住、要做的事情全部从大脑中清理出来，放入“收集箱”中。这个“收集箱”可以是笔记本、录音设备、电子文档等可以记录的工具，但首先，每天花上十几分钟，把在你脑中所有的信息、任务、灵感，通通用记录的方式移出，以免内存溢出。在彻底将自己的大脑“清空”后，要对“收集箱”中的信息进行处理。 1.2 处理 对“收集箱”中的信息进行处理，并承诺每周至少处理一次“收集箱”，保证“收集箱”里的信息不会堆积如山。 处理工作要遵循下列原则： 从第一条信息开始处理； 每次只处理一条信息； 将“收集箱”全部清空； 对于需要执行的项： 如果少于两分钟，马上去做（两分钟法则）； 将重要、紧急的事优先处理，但记住，重要、不紧急的对于长期来说更关键； 交由他人完成； 列入计划内，或延期完成。 否则： 将其存档以方便查询； 为它定义合适的目标与情境，以便下一步执行； 打包送入垃圾桶。 1.3 组织 将处理后的记录进行组织，分到下列四种集合中： 下一步行动（Next actions）：可以实际采取的下一步行动，其定义和情景应尽可能清晰； 项目（Projects）：需要大于一个实际的行动才能达到目的的事就是一个“项目”，使用跟踪以及周期性的回顾来确保每个项目都有一个下一步的行动进行下去； 等待完成（Waiting for）：指派给他人完成的事项，需要进行持续跟踪和定期检查； 将来/可能（Someday/Maybe）：需要在某种条件、某个时间点下去完成，但不是现在。 1.4 复盘 一般这一步会被译成回顾，但笔者更喜欢将其称为复盘，这是因为复盘是为了更好地总结这次的问题，以便之后不断加以改进。要做好复盘这步，需要达到以下三点： 保持记录的习惯，记录每日、每周事项的完成情况，和未完成原因； 在每日、每周、每月结尾的时候对当日、当周、当月的完成情况进行回顾和总结； 根据实际情况持续调整改进系统，以使其更符合自身情况和不断发展着的变化。 1.5 执行 最后，也是最关键的，去执行吧！否则前面做的一切都是无用功。换句话说，前面的工作都是为了让你在执行的过程中，能更加简单、高效，不会在各种各样的事情中迷失方向。当然了，具体执行的时候，需要一些方法和技巧： 集中注意力，拒绝干扰，包括微信、微博、蛤乎、邮件等一切能干扰你的东西； 对决定好的事情，坚决执行，绝不拖延； 采用番茄工作法（详见（三）番茄工作法）； 避免多任务，保持单进程，即是说一个时间段只专注于处理一件事，这一点很重要。 “因为我当时是看书还是谁跟我讲了一句很智慧的话，说你手里攥着千头万绪，工作是千头万绪，攥着一千个线头，但是一次针眼只能穿过一条线。” 2.图解GTD流程 图解GTD流程 3.番茄工作法3.1 GTD与番茄工作法 GTD作为一套时间管理系统，在具体执行上有一定的难度，如果没有一定自我控制能力和较好的时间管理方法，是很难在实践中运用好GTD的。因此，需要一套更易于实践的时间管理方法，以支持GTD在微观层面上的执行，比如番茄工作法。 3.2 番茄工作法简介 番茄工作法（Pomodoro）是一种简单易行的时间管理方法，由Francesco Cirillo创立。使用番茄工作法，必须要有一个番茄钟，可以选择在某宝上购买实体的，也可以用web或App上的，例如tomato-timer，一般一个番茄钟的时间为25分钟（也可以更长）。 另外，番茄不仅能用在工作/学习中，也可以用在休闲娱乐的时候，例如玩游戏或者看剧的时候，每隔25分钟就休息一下。 3.3 番茄工作法的步骤3.3.1 制作任务清单 番茄工作法首先要制订当日的任务清单（也就是当日Todo List），将当天要完成的事情列下来，并分解为若干个番茄。其中，超过4个番茄的任务要分解（个人习惯，可设为超过7个），不足1个的和其他零碎任务组合，直到变为一个完整的番茄。 3.3.2 专注于任务 从任务清单上选择一个待完成的任务，然后开始你的任务，中途不允许被任何与该任务无关的事所打扰，直到番茄时钟响起，然后可以获得一个5分钟的短休息，在四个番茄种后可以获得一个15分钟的长休息奖励。过程中的任何事务性干扰应被记录下来，待番茄钟结束后再去解决。// 如受某些不可抗力影响，番茄钟被打断，则需重新开始 3.3.3 填写任务清单 在番茄钟结束后，要在完成的任务后打勾，并记录下完成情况。 3.3.4 放轻松 在番茄钟间隔的短休息和长休息中，要好好地放轻松，可以浏览网页、回复信息，总之就是好好调整状态。 3.3.5 下一个流程 结束休息后，应立即、马上地转换状态，投入到下一个流程中。 4.结语 GTD是一套行之有效且需持续实践的系统，需要结合自身情况和不断变化着的实际，对GTD进行不断的迭代，使其成为一个更加可靠、可信赖的系统。在这个过程中，工具的角色虽不是决定性的，但也十分重要。因此笔者拟在完成个人博客的第二期建设后，集中精力开发一款GTD工具（结合番茄工作法），这篇博文就作为该项目的一个开端吧！","categories":[{"name":"其他文章","slug":"其他文章","permalink":"http://gaiusyao.cn/categories/其他文章/"}],"tags":[{"name":"GTD","slug":"GTD","permalink":"http://gaiusyao.cn/tags/GTD/"}]},{"title":"Hexo + GitHub Pages搭建个人博客","slug":"hello-world","date":"2017-10-14T16:00:00.000Z","updated":"2018-01-10T05:43:58.260Z","comments":true,"path":"2017/10/15/hello-world/","link":"","permalink":"http://gaiusyao.cn/2017/10/15/hello-world/","excerpt":"","text":"今天刚建好博客，还没什么内容可以放上来，就先从如何搭建个人博客（毕竟在这走了不少弯路）开始，写一篇微小的教程吧！首先，笔者的个人博客是使用Hexo + GitHub Pages搭建的。至于为什么要使用Hexo来搭建个人博客，而不是GitHub Pages钦定的jeklly，这和笔者被jeklly坑过完全没关系，主要是Hexo足够快速、简洁和高效。不过这里不展开介绍了，详细介绍可以看Hexo官网，英语不好的同学点这里。接着，我们先从Hexo的安装与常用命令开始，介绍如何使用Hexo + GitHub Pages搭建个人博客。 // 笔者系统环境为win10 1.Hexo的安装与常用命令1.1 安装前的准备 在安装Hexo前，需要先安装Noed.js以及Git，如果还未接触过两者，可参考下面的链接。 下载Node.js Node.js的安装和配置 下载Git 安装Git 1.2 安装Hexo 完成Noed.js和Git的安装后，先别急，花几分钟看看如何使用NPM，然后在命令行中按下面的代码进行操作。 12345678$ md hexo/blog # 创建hexo文件夹，win用户为\\$ cd hexo # 进入hexo文件夹$ npm install hexo-cli -g # 使用 npm 安装 Hexo$ hexo init blog $ cd blog $ npm install$ hexo g # == hexo generate，生成静态网站$ hexo s # == hexo server，启动服务器 完成上述操作后，打开http://localhost:4000/访问结果。 1.3 Hexo常用命令 hexo g(hexo generate) 生成静态文件 hexo s(hexo server) 启动本地web服务，用于预览 hexo d(hexo deploy) 部署到远端（如github） hexo n(hexo new) 新建页面或文章 hexo v(hexo version) 查看版本信息 hexo help 查看命令帮助 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo list 列出网站资料 2.GitHub Pages2.1 Github Pages介绍 GitHub Pages是全球最大同性交友网站GitHub免费提供给开发者的一款介绍托管项目的产品，多用于建设个人主页或项目介绍，因为本文侧重讲如何用Hexo + GitHub Pages搭建个人博客，这里就不做太多展开了，想要了解GitHub Pages的同学可以看下面两个链接： GitHub Pages主页 给懒癌患者看的GitHub Pages手册 2.2 部署Hexo到Github Pages 最激动人心的一步来了，将Hexo部署到Github Pages后，就可以在你的github.io上看到Hexo搭建的个人博客。不过，首先让我们明确要做什么，基本上部署到Github Pages就是两步：hexo g 生成静态网站和git commit提交代码，但具体操作需要使用hexo deploy或git命令行。 2.3 使用hexo deploy部署 使用hexo deploy部署，首先要安装一个拓展： 1$ npm install --save hexo-deployer-git 接着要在配置文件blog\\_config.yml的# Deployment下做如下修改： 1234deploy: type: git repo: git@github.com:jiji262/jiji262.github.io.git branch: master 然后在命令行中执行如下代码，即可完成部署。 1$ hexo d # 等同于hexo deploy // 关于使用hexo deploy部署，可参考这个链接 2.4 使用git命令行部署 使用git命令行进行部署也很简单，只需要先在blog下创建一个.deploy文件夹，再将创建的repo克隆(clone)到本地，然后按如下代码部署： 12345678$ cd d:/hexo/blog$ git clone git@github.com:gaiusyao/gaiusyao.github.io.git .deploy/jiji262.github.io$ hexo g # 等同于hexo generate$ cp -R public/* .deploy/gaiusyao.github.io #拷贝blog/public文件夹内容到git目录下$ cd .deploy/jiji262.github.io$ git add .$ git commit -m “update blog”$ git push origin master 3.Hexo主题3.1 使用Hexo主题 使用Hexo非常简单，首先在Hexo官网的主题页面挑选适合的主题，这里推荐笔者朋友的yolin主题，然后在blog下使用命令行执行： 1$ git clone https://github.com/GeekaholicLin/hexo-theme-ylion.git themes/yolin 修改blog目录下的_config.yml配置文件中的theme属性，将其设置为yolin，即可使用新的Hexo主题。 3.2 Hexo主题配置 Hexo主题的配置和你所采用的主题有关，不同的主题需要不同的配置，主题的配置文件是blog\\themes文件夹下的_config.yml。下面，以笔者使用的raytaylorism为例，介绍Hexo主题的配置项： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354menu: # 菜单配置（若不需要某项可直接删除） - id: home link: / icon: home class: menu-home - id: archives link: /archives icon: archive class: menu-archive - id: category link: javascript:; category: true icon: bookmark class: menu-category - id: reading link: /reading icon: book class: menu-reading - id: about link: /about icon: user class: menu-aboutcolor: # 颜色配置 header: blue footer: blue page_nav: blue side_nav: blue darken-1 tag: deep-orange lighten-1 article_title_link: blue link: deep-orange pagination: deep-orange tab: deep-orange archive_item: grey fab: deep-orange fab_2: cyan fab_3: orange darken-1 new: deep-orange about_header: blue about_title: bluearchive_yearly: truecopyright: © 2017 Gaius-Yao, All rights reserved. # 版权信息disqus_shortname: # Disqus评论shortname，若为空则不启用duoshuo_shortname: # 多说shortname，若为空则不启用yungentie_product_key: # 网易云跟帖productKey，从通用代码中获取，若为空则不启用google_analytics: # Google分析track id，若为空则不启用tencent_analytics: 63863615 # 腾讯分析sId，若为空则不启用google_code_prettify: prettify-tomorrow-night-eighties # 高亮的主题，若为空则使用默认主题mathjax: true # 是否启用MathJax数学公式渲染。如果你确认整个站点的博文都不会用到Latex数学公式，可以将其该项设为false提高页面加载速度page_stat: true # 是否启用网页计数器 3.3 创建Hexo主题 详见下篇Hexo教程——制作Hexo主题。 4.写博客4.1 创建新文章 Hexo写博客极其简单，可以执行下列命令来创建一篇新文章： 1$ hexo new [layout] &lt;title&gt; 4.2 布局(Layout)和标题(tilte) Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径： post: source/_posts page: source draft: source/_drafts 而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 // Hexo 默认以标题做为文件名称，但也可以在_config.yml编辑’new_post_name’修改默认文件名称。 4.3 写作和草稿 Hexo写作采用markdown语法，完成后使用hexo g即可生成静态html页面。 而使用上一部分提到的draft布局创建的草稿，在建立时会被保存到source/_drafts文件夹，可以通过publish命令将其移到source/_posts文件夹内发布： 1$ hexo publish [layout] &lt;title&gt; 4.4 模板(Scaffold) 在新建文章时，Hexo会根据scaffolds文件夹内相对应的文件（即模板）来建立文件，例如： 1$ hexo new photo \"My Gallery\" 在执行这行指令时，Hexo 会尝试在scaffolds文件夹中寻找photo.md，并根据其内容建立文章，以下是可以在模版中使用的变量： layout: 布局 title: 标题 date: 文件建立日期","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://gaiusyao.cn/categories/个人博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://gaiusyao.cn/tags/Hexo/"}]}]}