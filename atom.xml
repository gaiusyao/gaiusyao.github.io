<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gaius Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gaiusyao.cn/"/>
  <updated>2018-01-10T05:45:08.810Z</updated>
  <id>http://gaiusyao.cn/</id>
  
  <author>
    <name>Gaius Yao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python数据可视化01：Pandas</title>
    <link href="http://gaiusyao.cn/2018/01/09/pandas/"/>
    <id>http://gaiusyao.cn/2018/01/09/pandas/</id>
    <published>2018-01-09T10:07:00.000Z</published>
    <updated>2018-01-10T05:45:08.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-pandas简介"><a href="#1-pandas简介" class="headerlink" title="1.pandas简介"></a>1.pandas简介</h2><p>&emsp; &emsp; 首先引用官方介绍：“pandas是一个采用BSD协议的开源库，为Python编程语言提供了高性能，易于使用的数据结构和数据分析工具。”这里不做过多展开，让我们马上通过一个实例来展示pandas的功能吧！首先导入相关库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h2 id="2-文件读取"><a href="#2-文件读取" class="headerlink" title="2.文件读取"></a>2.文件读取</h2><p>&emsp;&emsp;这里以读取csv文件为例，介绍3种常用的数据读取函数：</p><ul><li>df = pd.read_csv(path=’file.csv’)</li><li>df = pd.read_json(‘file.json’) <em>#可以传入json格式字符串</em></li><li>df = pd.read_excel(‘file.xls’, sheetname=[0,1..]) <em>#读取多个sheet，返回多个df的字典</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">dc = pd.read_csv(<span class="string">'data/dc.csv'</span>)</span><br><span class="line">marvel = pd.read_csv(<span class="string">'data/marvel.csv'</span>)</span><br></pre></td></tr></table></figure><h2 id="3-查看DateFrame"><a href="#3-查看DateFrame" class="headerlink" title="3.查看DateFrame"></a>3.查看DateFrame</h2><p>&emsp;&emsp;在导入数据集后，我们可以通过下列函数来查看DateFrame：</p><ul><li>df.info() <em>#查看DateFrame信息</em></li><li>df.describe() <em>#描述性统计</em></li><li>df.columns <em>#查看列名</em></li><li>df.index <em>#查看索引</em></li><li>df.head() <em>#查看DateFrame头五行</em></li><li>df.tail() <em>#查看DateFrame尾五行</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.info()</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 6896 entries, 0 to 6895Data columns (total 13 columns):page_id             6896 non-null int64name                6896 non-null objecturlslug             6896 non-null objectID                  4883 non-null objectALIGN               6295 non-null objectEYE                 3268 non-null objectHAIR                4622 non-null objectSEX                 6771 non-null objectGSM                 64 non-null objectALIVE               6893 non-null objectAPPEARANCES         6541 non-null float64FIRST APPEARANCE    6827 non-null objectYEAR                6827 non-null float64dtypes: float64(2), int64(1), object(10)memory usage: 700.5+ KB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marvel.info()</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 16376 entries, 0 to 16375Data columns (total 13 columns):page_id             16376 non-null int64name                16376 non-null objecturlslug             16376 non-null objectID                  12606 non-null objectALIGN               13564 non-null objectEYE                 6609 non-null objectHAIR                12112 non-null objectSEX                 15522 non-null objectGSM                 90 non-null objectALIVE               16373 non-null objectAPPEARANCES         15280 non-null float64FIRST APPEARANCE    15561 non-null objectYear                15561 non-null float64dtypes: float64(2), int64(1), object(10)memory usage: 1.6+ MB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.columns</span><br></pre></td></tr></table></figure><pre><code>Index([&apos;page_id&apos;, &apos;name&apos;, &apos;urlslug&apos;, &apos;ID&apos;, &apos;ALIGN&apos;, &apos;EYE&apos;, &apos;HAIR&apos;, &apos;SEX&apos;,       &apos;GSM&apos;, &apos;ALIVE&apos;, &apos;APPEARANCES&apos;, &apos;FIRST APPEARANCE&apos;, &apos;YEAR&apos;],      dtype=&apos;object&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marvel.columns</span><br></pre></td></tr></table></figure><pre><code>Index([&apos;page_id&apos;, &apos;name&apos;, &apos;urlslug&apos;, &apos;ID&apos;, &apos;ALIGN&apos;, &apos;EYE&apos;, &apos;HAIR&apos;, &apos;SEX&apos;,       &apos;GSM&apos;, &apos;ALIVE&apos;, &apos;APPEARANCES&apos;, &apos;FIRST APPEARANCE&apos;, &apos;Year&apos;],      dtype=&apos;object&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统一列名</span></span><br><span class="line">marvel.rename(columns=&#123;<span class="string">'Year'</span>:<span class="string">'YEAR'</span>&#125;, inplace = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.index</span><br></pre></td></tr></table></figure><pre><code>RangeIndex(start=0, stop=6896, step=1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marvel.tail() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><h2 id="4-缺失值处理"><a href="#4-缺失值处理" class="headerlink" title="4.缺失值处理"></a>4.缺失值处理</h2><p>&emsp;&emsp;在上一步，我们可以看到DateFrame中有不少数据是缺失的（显示为<code>NaN</code>），我们可以通过<strong>dropna()函数</strong>去掉含有缺失数据的行，但在这里，我们希望保留这些行，因此使用<strong>fillna()函数</strong>填充缺失的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将marvel数据集EYE列缺失的数据填充为Unknow</span></span><br><span class="line">marvel[<span class="string">'EYE'</span>].fillna(<span class="string">'UnKnown'</span>)</span><br></pre></td></tr></table></figure><pre><code>0         Hazel Eyes1          Blue Eyes2          Blue Eyes3          Blue Eyes4          Blue Eyes5          Blue Eyes6         Brown Eyes7         Brown Eyes8         Brown Eyes9          Blue Eyes10         Blue Eyes11         Blue Eyes12        Green Eyes13         Blue Eyes14         Blue Eyes15         Blue Eyes16         Grey Eyes17        Green Eyes18         Blue Eyes19        Brown Eyes20         Blue Eyes21         Blue Eyes22         Blue Eyes23         Blue Eyes24        Green Eyes25        Brown Eyes26         Blue Eyes27        Green Eyes28        Green Eyes29       Yellow Eyes            ...     16346        UnKnown16347        UnKnown16348        UnKnown16349     White Eyes16350        UnKnown16351        UnKnown16352        UnKnown16353        UnKnown16354        UnKnown16355        UnKnown16356        UnKnown16357        UnKnown16358        UnKnown16359     Black Eyes16360     Black Eyes16361        UnKnown16362       Red Eyes16363     Black Eyes16364     Hazel Eyes16365        UnKnown16366     Brown Eyes16367     Hazel Eyes16368        UnKnown16369      Blue Eyes16370        UnKnown16371     Green Eyes16372      Blue Eyes16373     Black Eyes16374        UnKnown16375        UnKnownName: EYE, Length: 16376, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有缺失数据填充为UnKnown</span></span><br><span class="line">dc = dc.fillna(<span class="string">'UnKnown'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marvel = marvel.fillna(<span class="string">'UnKnown'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><h2 id="5-添加-插入行列"><a href="#5-添加-插入行列" class="headerlink" title="5.添加/插入行列"></a>5.添加/插入行列</h2><p>&emsp;&emsp;接下来我们为两个DateFrame添加<code>COMPANY</code>列，并演示如何插入行列。其中插入行的过程会略复杂，需要先切割，再拼接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">marvel[<span class="string">'COMPANY'</span>] = <span class="string">'Marvel'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dc[<span class="string">'COMPANY'</span>] = <span class="string">'DC'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否添加成功</span></span><br><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将page_id列取出</span></span><br><span class="line">page_id = dc.pop(<span class="string">'page_id'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否取出成功</span></span><br><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新插入page_id列</span></span><br><span class="line">dc.insert(<span class="number">0</span>, <span class="string">'page_id'</span>, page_id)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否插入成功</span></span><br><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建需要插入的行的数据</span></span><br><span class="line">insertRow = pd.DataFrame([[<span class="number">42</span>, <span class="string">'Gaius'</span>, <span class="string">'Unknown'</span>, <span class="string">'Secret Identity'</span>, <span class="string">'Good Characters'</span>,<span class="string">'Blake Eyes'</span>, <span class="string">'Black Hair'</span>, <span class="string">'Male Characters'</span>, <span class="string">'Unknown'</span>, <span class="string">'Living Characters'</span>, <span class="string">'2333.0'</span>, <span class="string">'1995, August'</span>, <span class="string">'1995'</span>, <span class="string">'Unknown'</span>]],</span><br><span class="line">                         columns=[<span class="string">'page_id'</span>, <span class="string">'name'</span>, <span class="string">'urlslug'</span>, <span class="string">'ID'</span>, <span class="string">'ALIGN'</span>, <span class="string">'EYE'</span>, <span class="string">'HAIR'</span>, <span class="string">'SEX'</span>, <span class="string">'GSM'</span>, <span class="string">'ALIVE'</span>, <span class="string">'APPEARANCES'</span>, <span class="string">'FIRST APPEARANCE'</span>, <span class="string">'YEAR'</span>, <span class="string">'COMPANY'</span>])</span><br><span class="line"><span class="comment"># 将dc分割为above和below</span></span><br><span class="line">above = dc.loc[:<span class="number">2</span>]</span><br><span class="line">below = dc.loc[<span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 拼接above和below</span></span><br><span class="line">dc = above.append(insertRow,ignore_index=<span class="keyword">True</span>).append(below,ignore_index=<span class="keyword">True</span>)</span><br><span class="line">dc.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><h2 id="6-合并DateFrame"><a href="#6-合并DateFrame" class="headerlink" title="6.合并DateFrame"></a>6.合并DateFrame</h2><p>&emsp;&emsp;通过<strong>concat()函数</strong>合并DateFrame——<code>pd.concat(list)</code>，<code>list</code>中为各个DateFrame。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comic = pd.concat([dc, marvel], ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comic.info()</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 23273 entries, 0 to 23272Data columns (total 14 columns):page_id             23273 non-null int64name                23273 non-null objecturlslug             23273 non-null objectID                  23273 non-null objectALIGN               23273 non-null objectEYE                 23273 non-null objectHAIR                23273 non-null objectSEX                 23273 non-null objectGSM                 23273 non-null objectALIVE               23273 non-null objectAPPEARANCES         23273 non-null objectFIRST APPEARANCE    23273 non-null objectYEAR                23273 non-null objectCOMPANY             23273 non-null objectdtypes: int64(1), object(13)memory usage: 2.5+ MB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comic.head() <span class="comment">#结果略</span></span><br></pre></td></tr></table></figure><h2 id="7-导出数据"><a href="#7-导出数据" class="headerlink" title="7.导出数据"></a>7.导出数据</h2><p>&emsp;&emsp;通过<strong>to_csv()函数</strong>导出数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comic.to_csv(<span class="string">'data/comic_characters.csv'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/gaiusyao/pivotlab/blob/master/ipynb/gaius_blog/pandas.ipynb" target="_blank" rel="noopener">文章源代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-pandas简介&quot;&gt;&lt;a href=&quot;#1-pandas简介&quot; class=&quot;headerlink&quot; title=&quot;1.pandas简介&quot;&gt;&lt;/a&gt;1.pandas简介&lt;/h2&gt;&lt;p&gt;&amp;emsp; &amp;emsp; 首先引用官方介绍：“pandas是一个采用BSD
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python数据可视化" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
      <category term="数据可视化" scheme="http://gaiusyao.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python分析葡萄酒质量</title>
    <link href="http://gaiusyao.cn/2017/11/04/wine-quality/"/>
    <id>http://gaiusyao.cn/2017/11/04/wine-quality/</id>
    <published>2017-11-04T12:30:48.000Z</published>
    <updated>2018-01-10T05:46:55.122Z</updated>
    
    <content type="html"><![CDATA[<p>  本篇博文是作者在阅读完<em>Foundations for Analytics with Python</em>一书后，使用Python进行数据分析的一次实战，所用数据集为<a href="https://github.com/gaiusyao/pivotlab/blob/master/datawarehouse/gaiusyao-blog/winequality-both.csv" target="_blank" rel="noopener">葡萄酒质量数据集</a>，该数据集是由UCI机器学习资料库中找到的两个数据集合并成的:</p><ul><li><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv" target="_blank" rel="noopener">红葡萄酒</a></li><li><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv" target="_blank" rel="noopener">白葡萄酒</a></li></ul><h2 id="1-描述性统计"><a href="#1-描述性统计" class="headerlink" title="1.描述性统计"></a>1.描述性统计</h2><h3 id="1-1-将数据集读入数据框"><a href="#1-1-将数据集读入数据框" class="headerlink" title="1.1 将数据集读入数据框"></a>1.1 将数据集读入数据框</h3><p>  在下面的代码中，首先完成了<code>import</code>工作，将所需的包加载到脚本中。之后用<code>pandas</code>的<code>read_csv</code>方法将文本文件<em>csv\winequality-both.csv</em>读入到数据框<code>wine</code>中，并将列标题中包含的空格替换为<code>_</code>。最后通过<code>head</code>方法打印出下标题行和前5行数据，以确保数据被正确地加载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br><span class="line"><span class="keyword">from</span> statsmodels.formula.api <span class="keyword">import</span> ols, glm</span><br><span class="line"></span><br><span class="line">wine = pd.read_csv(<span class="string">'csv\winequality-both.csv'</span>, sep=<span class="string">','</span>, header=<span class="number">0</span>)</span><br><span class="line">wine.columns = wine.columns.str.replace(<span class="string">' '</span>, <span class="string">'_'</span>)</span><br><span class="line">print(wine.head())</span><br></pre></td></tr></table></figure><pre><code>  type  fixed_acidity  volatile_acidity  citric_acid  residual_sugar  \0  red            7.4              0.70         0.00             1.9   1  red            7.8              0.88         0.00             2.6   2  red            7.8              0.76         0.04             2.3   3  red           11.2              0.28         0.56             1.9   4  red            7.4              0.70         0.00             1.9      chlorides  free_sulfur_dioxide  total_sulfur_dioxide  density    pH  \0      0.076                 11.0                  34.0   0.9978  3.51   1      0.098                 25.0                  67.0   0.9968  3.20   2      0.092                 15.0                  54.0   0.9970  3.26   3      0.075                 17.0                  60.0   0.9980  3.16   4      0.076                 11.0                  34.0   0.9978  3.51      sulphates  alcohol  quality  0       0.56      9.4        5  1       0.68      9.8        5  2       0.65      9.8        5  3       0.58      9.8        6  4       0.56      9.4        5  </code></pre><h3 id="1-2-显示所有变量的描述性统计量"><a href="#1-2-显示所有变量的描述性统计量" class="headerlink" title="1.2 显示所有变量的描述性统计量"></a>1.2 显示所有变量的描述性统计量</h3><p>  通过<code>describe</code>方法，打印出在所有变量的描述性统计量，包括总数、均值、标准差、最小值、第25个百分位数、中位数、第75个百分位数和最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(wine.describe())</span><br></pre></td></tr></table></figure><pre><code>       fixed_acidity  volatile_acidity  citric_acid  residual_sugar  \count    6497.000000       6497.000000  6497.000000     6497.000000   mean        7.215307          0.339666     0.318633        5.443235   std         1.296434          0.164636     0.145318        4.757804   min         3.800000          0.080000     0.000000        0.600000   25%         6.400000          0.230000     0.250000        1.800000   50%         7.000000          0.290000     0.310000        3.000000   75%         7.700000          0.400000     0.390000        8.100000   max        15.900000          1.580000     1.660000       65.800000            chlorides  free_sulfur_dioxide  total_sulfur_dioxide      density  \count  6497.000000          6497.000000           6497.000000  6497.000000   mean      0.056034            30.525319            115.744574     0.994697   std       0.035034            17.749400             56.521855     0.002999   min       0.009000             1.000000              6.000000     0.987110   25%       0.038000            17.000000             77.000000     0.992340   50%       0.047000            29.000000            118.000000     0.994890   75%       0.065000            41.000000            156.000000     0.996990   max       0.611000           289.000000            440.000000     1.038980                   pH    sulphates      alcohol      quality  count  6497.000000  6497.000000  6497.000000  6497.000000  mean      3.218501     0.531268    10.491801     5.818378  std       0.160787     0.148806     1.192712     0.873255  min       2.720000     0.220000     8.000000     3.000000  25%       3.110000     0.430000     9.500000     5.000000  50%       3.210000     0.510000    10.300000     6.000000  75%       3.320000     0.600000    11.300000     6.000000  max       4.010000     2.000000    14.900000     9.000000  </code></pre><h3 id="1-3-分析质量列"><a href="#1-3-分析质量列" class="headerlink" title="1.3 分析质量列"></a>1.3 分析质量列</h3><p>  从1.2中的结果我们可以得知，质量列中有6497个观测，范围从3到9，平均数为5.8，标准差为0.87。通过<code>unique</code>方法，识别出质量列中的唯一值，并以升序打印在屏幕上，输出显示质量列中的唯一值是3、4、5、6、7、8 和9。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(sorted(wine.quality.unique()))</span><br></pre></td></tr></table></figure><pre><code>[3, 4, 5, 6, 7, 8, 9]</code></pre><p>  接着计算质量列中唯一值出现的频率，可以看到质量评分为6的最多，有2836个观测，而质量评分最高分9则最少，只有5个观测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(wine.quality.value_counts())</span><br></pre></td></tr></table></figure><pre><code>6    28365    21387    10794     2168     1933      309       5Name: quality, dtype: int64</code></pre><h3 id="1-4-分组显示"><a href="#1-4-分组显示" class="headerlink" title="1.4 分组显示"></a>1.4 分组显示</h3><p>  前面计算出的统计量是针对整个数据集的，既包括红葡萄酒数据也包括白葡萄酒数据。下面通过<code>groupby</code>方法，按照葡萄酒类型（<code>type</code>）分别显示红葡萄酒和白葡萄酒的描述性统计量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(wine.groupby(<span class="string">'type'</span>)[[<span class="string">'alcohol'</span>]].describe().unstack(<span class="string">'type'</span>))</span><br></pre></td></tr></table></figure><pre><code>                type alcohol  count  red      1599.000000                white    4898.000000         mean   red        10.422983                white      10.514267         std    red         1.065668                white       1.230621         min    red         8.400000                white       8.000000         25%    red         9.500000                white       9.500000         50%    red        10.200000                white      10.400000         75%    red        11.100000                white      11.400000         max    red        14.900000                white      14.200000dtype: float64</code></pre><p>  接着，使用<code>quantile</code>函数对质量列计算第25百分位数和第75百分位数，并按照葡萄酒类型显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(wine.groupby(<span class="string">'type'</span>)[[<span class="string">'quality'</span>]].quantile([<span class="number">0.25</span>, <span class="number">0.75</span>]).unstack(<span class="string">'type'</span>))</span><br></pre></td></tr></table></figure><pre><code>     quality      type     red white0.25     5.0   5.00.75     6.0   6.0</code></pre><h3 id="1-5-相关矩阵"><a href="#1-5-相关矩阵" class="headerlink" title="1.5 相关矩阵"></a>1.5 相关矩阵</h3><p>  这里通过<code>corr</code>方法计算得到所有变量的相关矩阵，结果将会在后面用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(wine.corr())</span><br></pre></td></tr></table></figure><pre><code>                      fixed_acidity  volatile_acidity  citric_acid  \fixed_acidity              1.000000          0.219008     0.324436   volatile_acidity           0.219008          1.000000    -0.377981   citric_acid                0.324436         -0.377981     1.000000   residual_sugar            -0.111981         -0.196011     0.142451   chlorides                  0.298195          0.377124     0.038998   free_sulfur_dioxide       -0.282735         -0.352557     0.133126   total_sulfur_dioxide      -0.329054         -0.414476     0.195242   density                    0.458910          0.271296     0.096154   pH                        -0.252700          0.261454    -0.329808   sulphates                  0.299568          0.225984     0.056197   alcohol                   -0.095452         -0.037640    -0.010493   quality                   -0.076743         -0.265699     0.085532                         residual_sugar  chlorides  free_sulfur_dioxide  \fixed_acidity              -0.111981   0.298195            -0.282735   volatile_acidity           -0.196011   0.377124            -0.352557   citric_acid                 0.142451   0.038998             0.133126   residual_sugar              1.000000  -0.128940             0.402871   chlorides                  -0.128940   1.000000            -0.195045   free_sulfur_dioxide         0.402871  -0.195045             1.000000   total_sulfur_dioxide        0.495482  -0.279630             0.720934   density                     0.552517   0.362615             0.025717   pH                         -0.267320   0.044708            -0.145854   sulphates                  -0.185927   0.395593            -0.188457   alcohol                    -0.359415  -0.256916            -0.179838   quality                    -0.036980  -0.200666             0.055463                         total_sulfur_dioxide   density        pH  sulphates  \fixed_acidity                    -0.329054  0.458910 -0.252700   0.299568   volatile_acidity                 -0.414476  0.271296  0.261454   0.225984   citric_acid                       0.195242  0.096154 -0.329808   0.056197   residual_sugar                    0.495482  0.552517 -0.267320  -0.185927   chlorides                        -0.279630  0.362615  0.044708   0.395593   free_sulfur_dioxide               0.720934  0.025717 -0.145854  -0.188457   total_sulfur_dioxide              1.000000  0.032395 -0.238413  -0.275727   density                           0.032395  1.000000  0.011686   0.259478   pH                               -0.238413  0.011686  1.000000   0.192123   sulphates                        -0.275727  0.259478  0.192123   1.000000   alcohol                          -0.265740 -0.686745  0.121248  -0.003029   quality                          -0.041385 -0.305858  0.019506   0.038485                          alcohol   quality  fixed_acidity        -0.095452 -0.076743  volatile_acidity     -0.037640 -0.265699  citric_acid          -0.010493  0.085532  residual_sugar       -0.359415 -0.036980  chlorides            -0.256916 -0.200666  free_sulfur_dioxide  -0.179838  0.055463  total_sulfur_dioxide -0.265740 -0.041385  density              -0.686745 -0.305858  pH                    0.121248  0.019506  sulphates            -0.003029  0.038485  alcohol               1.000000  0.444319  quality               0.444319  1.000000  </code></pre><h2 id="2-直方图与t检验"><a href="#2-直方图与t检验" class="headerlink" title="2.直方图与t检验"></a>2.直方图与t检验</h2><p>  这里通过<code>seaborn</code>包创建一幅统计图，图中有两个直方图，分别表示红葡萄酒和白葡萄酒。从下图可以看出，两种葡萄酒的评分都近似正态分布。与原始数据的摘要统计量相比，直方图更容易看出两种葡萄酒的质量评分的分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">red_wine = wine.loc[wine[<span class="string">'type'</span>]==<span class="string">'red'</span>, <span class="string">'quality'</span>]</span><br><span class="line">white_wine = wine.loc[wine[<span class="string">'type'</span>]==<span class="string">'white'</span>, <span class="string">'quality'</span>]</span><br><span class="line">sns.set_style(<span class="string">"dark"</span>)</span><br><span class="line">print(sns.distplot(red_wine, \</span><br><span class="line">norm_hist=<span class="keyword">True</span>, kde=<span class="keyword">False</span>, color=<span class="string">"red"</span>, label=<span class="string">"Red wine"</span>, axlabel=<span class="keyword">False</span>))</span><br><span class="line">print(sns.distplot(white_wine, \</span><br><span class="line">norm_hist=<span class="keyword">True</span>, kde=<span class="keyword">False</span>, color=<span class="string">"white"</span>, label=<span class="string">"White wine"</span>, axlabel=<span class="keyword">False</span>))</span><br><span class="line">plt.title(<span class="string">"Distribution of Quality by Wine Type"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxv2o8wp9.bkt.clouddn.com/output_7_1.png" alt="直方图" title="">                </div>                <div class="image-caption">直方图</div>            </figure><p>  接着，进行一下<strong>t检验</strong>，判断红葡萄酒和白葡萄酒的平均评分是否有区别。下面的代码演示了如何使用<code>groupby</code>和<code>agg</code>函数来为数据集中的分组计算一系列统计量。从结果中，我们可以得知，白葡萄酒的平均质量评分在统计意义上大于红葡萄酒的平均质量评分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(wine.groupby([<span class="string">'type'</span>])[[<span class="string">'quality'</span>]].agg([<span class="string">'std'</span>]))</span><br><span class="line">tstat, pvalue, df = sm.stats.ttest_ind(red_wine, white_wine)</span><br><span class="line">print(<span class="string">'tstat: %.3f pvalue: %.4f'</span> % (tstat, pvalue))</span><br></pre></td></tr></table></figure><pre><code>        quality            stdtype           red    0.807569white  0.885639tstat: -9.686 pvalue: 0.0000</code></pre><h2 id="3-成对变量之间的关系和相关性"><a href="#3-成对变量之间的关系和相关性" class="headerlink" title="3.成对变量之间的关系和相关性"></a>3.成对变量之间的关系和相关性</h2><p>  前面已经检查了输出变量，下面简单研究一下输入变量。让我们计算一下输入变量两两之间的相关性，在1.5我们用<code>corr</code>函数计算出数据集中所有变量的相关矩阵，它揭示了所有变量两两之间的线性相关性——酒精含量、硫酸盐、pH 值、游离二氧化硫和柠檬酸这些指标与质量是正相关的，相反，非挥发性酸、挥发性酸、残余糖分、氯化物、总二氧化硫和密度这些指标与质量是负相关的。下面的代码则将从红葡萄酒和白葡萄酒的数据中抽样取出一个“小”样本（200条红葡萄酒数据和200条白葡萄酒数据）来进行绘图，并通过<code>seaborn</code>的<code>pairplot</code>函数创建一个统计图矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take_sample</span><span class="params">(data_frame, replace=False, n=<span class="number">200</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> data_frame.loc[np.random.choice(data_frame.index, replace=replace, size=n)]</span><br><span class="line">reds_sample = take_sample(wine.loc[wine[<span class="string">'type'</span>]==<span class="string">'red'</span>, :])</span><br><span class="line">whites_sample = take_sample(wine.loc[wine[<span class="string">'type'</span>]==<span class="string">'white'</span>, :])</span><br><span class="line">wine_sample = pd.concat([reds_sample, whites_sample])</span><br><span class="line">wine[<span class="string">'in_sample'</span>] = np.where(wine.index.isin(wine_sample.index), <span class="number">1.</span>,<span class="number">0.</span>)</span><br><span class="line">print(pd.crosstab(wine.in_sample, wine.type, margins=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">"dark"</span>)</span><br><span class="line">g = sns.pairplot(wine_sample, kind=<span class="string">'reg'</span>, plot_kws=&#123;<span class="string">"ci"</span>: <span class="keyword">False</span>,\</span><br><span class="line"><span class="string">"x_jitter"</span>: <span class="number">0.25</span>, <span class="string">"y_jitter"</span>: <span class="number">0.25</span>&#125;, hue=<span class="string">'type'</span>, diag_kind=<span class="string">'hist'</span>,\</span><br><span class="line">diag_kws=&#123;<span class="string">"bins"</span>: <span class="number">10</span>, <span class="string">"alpha"</span>: <span class="number">1.0</span>&#125;, palette=dict(red=<span class="string">"red"</span>, white=<span class="string">"white"</span>),\</span><br><span class="line">markers=[<span class="string">"o"</span>, <span class="string">"s"</span>], vars=[<span class="string">'quality'</span>, <span class="string">'alcohol'</span>, <span class="string">'residual_sugar'</span>])</span><br><span class="line">print(g)</span><br><span class="line">plt.suptitle(<span class="string">'Histograms and Scatter Plots of Quality, Alcohol, and Residual\</span></span><br><span class="line"><span class="string">Sugar'</span>, fontsize=<span class="number">14</span>, horizontalalignment=<span class="string">'center'</span>, verticalalignment=<span class="string">'top'</span>,\</span><br><span class="line">x=<span class="number">0.5</span>, y=<span class="number">0.999</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>  下方的统计图矩阵显示了葡萄酒质量、酒精含量和残余糖分之间的关系。红条和红点表示红葡萄酒，白条和白点表示白葡萄酒。主对角线上的图以直方图或密度图的形式显示了每个变量的单变量分布，对角线之外的图以散点图的形式显示了每两个变量之间的双变量分布，散点图中可以有回归直线，也可以没有。   </p><p><img src="http://oxv2o8wp9.bkt.clouddn.com/output_10_1.png" alt="统计图矩阵"></p><p>  从这些统计图可以看出，对于红葡萄酒和白葡萄酒来说，酒精含量的均值和标准差是大致相同的，但是，白葡萄酒残余糖分的均值和标准差却大于红葡萄酒残余糖分的均值和标准差。从回归直线可以看出，对于两种类型的葡萄酒，酒精含量增加时，质量评分也随之提高，相反，残余糖分增加时，质量评分则随之降低。这两个变量对白葡萄酒的影响都要大于对红葡萄酒的影响。  </p><h2 id="4-使用最小二乘估计进行线性回归"><a href="#4-使用最小二乘估计进行线性回归" class="headerlink" title="4.使用最小二乘估计进行线性回归"></a>4.使用最小二乘估计进行线性回归</h2><p>  这里使用使用<code>statsmodel</code>包来进行线性回归, 首先将一个包含回归公式定义的字符串赋给<code>my_formula</code> 。在该字符串中，<code>~</code>左侧的变量<code>quality</code>是因变量，右侧的均为自变量。接下来用公式和数据拟合一个普通最小二乘回归模型，并将结果赋给变量<code>lm</code>。最后打印模型的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my_formula = <span class="string">'quality ~ alcohol + chlorides + citric_acid + density\</span></span><br><span class="line"><span class="string">+ fixed_acidity + free_sulfur_dioxide + pH + residual_sugar + sulphates\</span></span><br><span class="line"><span class="string">+ total_sulfur_dioxide + volatile_acidity'</span></span><br><span class="line">lm = ols(my_formula, data=wine).fit()</span><br><span class="line">print(lm.summary())</span><br><span class="line">print(<span class="string">"\nQuantities you can extract from the result:\n%s"</span> % dir(lm))</span><br><span class="line">print(<span class="string">"\nCoefficients:\n%s"</span> % lm.params)</span><br><span class="line">print(<span class="string">"\nCoefficient Std Errors:\n%s"</span> % lm.bse)</span><br><span class="line">print(<span class="string">"\nAdj. R-squared:\n%.2f"</span> % lm.rsquared_adj)</span><br><span class="line">print(<span class="string">"\nF-statistic: %.1f  P-value: %.2f"</span> % (lm.fvalue, lm.f_pvalue))</span><br><span class="line">print(<span class="string">"\nNumber of obs: %d  Number of fitted values: %s"</span> % (lm.nobs, len(lm.fittedvalues)))</span><br></pre></td></tr></table></figure><pre><code>                            OLS Regression Results                            ==============================================================================Dep. Variable:                quality   R-squared:                       0.292Model:                            OLS   Adj. R-squared:                  0.291Method:                 Least Squares   F-statistic:                     243.3Date:                Thu, 09 Nov 2017   Prob (F-statistic):               0.00Time:                        08:35:41   Log-Likelihood:                -7215.5No. Observations:                6497   AIC:                         1.445e+04Df Residuals:                    6485   BIC:                         1.454e+04Df Model:                          11                                         Covariance Type:            nonrobust                                         ========================================================================================                           coef    std err          t      P&gt;|t|      [0.025      0.975]----------------------------------------------------------------------------------------Intercept               55.7627     11.894      4.688      0.000      32.447      79.079alcohol                  0.2670      0.017     15.963      0.000       0.234       0.300chlorides               -0.4837      0.333     -1.454      0.146      -1.136       0.168citric_acid             -0.1097      0.080     -1.377      0.168      -0.266       0.046density                -54.9669     12.137     -4.529      0.000     -78.760     -31.173fixed_acidity            0.0677      0.016      4.346      0.000       0.037       0.098free_sulfur_dioxide      0.0060      0.001      7.948      0.000       0.004       0.007pH                       0.4393      0.090      4.861      0.000       0.262       0.616residual_sugar           0.0436      0.005      8.449      0.000       0.033       0.054sulphates                0.7683      0.076     10.092      0.000       0.619       0.917total_sulfur_dioxide    -0.0025      0.000     -8.969      0.000      -0.003      -0.002volatile_acidity        -1.3279      0.077    -17.162      0.000      -1.480      -1.176==============================================================================Omnibus:                      144.075   Durbin-Watson:                   1.646Prob(Omnibus):                  0.000   Jarque-Bera (JB):              324.712Skew:                          -0.006   Prob(JB):                     3.09e-71Kurtosis:                       4.095   Cond. No.                     2.49e+05==============================================================================Quantities you can extract from the result:[&apos;HC0_se&apos;, &apos;HC1_se&apos;, &apos;HC2_se&apos;, &apos;HC3_se&apos;, &apos;_HCCM&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_cache&apos;, &apos;_data_attr&apos;, &apos;_get_robustcov_results&apos;, &apos;_is_nested&apos;, &apos;_wexog_singular_values&apos;, &apos;aic&apos;, &apos;bic&apos;, &apos;bse&apos;, &apos;centered_tss&apos;, &apos;compare_f_test&apos;, &apos;compare_lm_test&apos;, &apos;compare_lr_test&apos;, &apos;condition_number&apos;, &apos;conf_int&apos;, &apos;conf_int_el&apos;, &apos;cov_HC0&apos;, &apos;cov_HC1&apos;, &apos;cov_HC2&apos;, &apos;cov_HC3&apos;, &apos;cov_kwds&apos;, &apos;cov_params&apos;, &apos;cov_type&apos;, &apos;df_model&apos;, &apos;df_resid&apos;, &apos;diagn&apos;, &apos;eigenvals&apos;, &apos;el_test&apos;, &apos;ess&apos;, &apos;f_pvalue&apos;, &apos;f_test&apos;, &apos;fittedvalues&apos;, &apos;fvalue&apos;, &apos;get_influence&apos;, &apos;get_prediction&apos;, &apos;get_robustcov_results&apos;, &apos;initialize&apos;, &apos;k_constant&apos;, &apos;llf&apos;, &apos;load&apos;, &apos;model&apos;, &apos;mse_model&apos;, &apos;mse_resid&apos;, &apos;mse_total&apos;, &apos;nobs&apos;, &apos;normalized_cov_params&apos;, &apos;outlier_test&apos;, &apos;params&apos;, &apos;predict&apos;, &apos;pvalues&apos;, &apos;remove_data&apos;, &apos;resid&apos;, &apos;resid_pearson&apos;, &apos;rsquared&apos;, &apos;rsquared_adj&apos;, &apos;save&apos;, &apos;scale&apos;, &apos;ssr&apos;, &apos;summary&apos;, &apos;summary2&apos;, &apos;t_test&apos;, &apos;tvalues&apos;, &apos;uncentered_tss&apos;, &apos;use_t&apos;, &apos;wald_test&apos;, &apos;wald_test_terms&apos;, &apos;wresid&apos;]Coefficients:Intercept               55.762750alcohol                  0.267030chlorides               -0.483714citric_acid             -0.109657density                -54.966942fixed_acidity            0.067684free_sulfur_dioxide      0.005970pH                       0.439296residual_sugar           0.043559sulphates                0.768252total_sulfur_dioxide    -0.002481volatile_acidity        -1.327892dtype: float64Coefficient Std Errors:Intercept               11.893899alcohol                  0.016728chlorides                0.332683citric_acid              0.079619density                 12.137473fixed_acidity            0.015573free_sulfur_dioxide      0.000751pH                       0.090371residual_sugar           0.005156sulphates                0.076123total_sulfur_dioxide     0.000277volatile_acidity         0.077373dtype: float64Adj. R-squared:0.29F-statistic: 243.3  P-value: 0.00Number of obs: 6497  Number of fitted values: 6497</code></pre><h2 id="5-自变量标准化"><a href="#5-自变量标准化" class="headerlink" title="5.自变量标准化"></a>5.自变量标准化</h2><p>  这里尝试使用<code>pandas</code>包在数据框中对变量进行标准化，首先创建了一个名为<code>dependent_variable</code>的序列来保存质量数据，以及创建了一个名为<code>independent_variables</code>的数据框来保存初始的葡萄酒数据集中除quality、type和in_sample之外的所有变量。接着，对每个变量，在每个观测中减去变量的均值，并且使用结果除以变量的标准差，以对其进行标准化。然后将因变量<code>quality</code>作为一列添加到自变量数据框中，并创建一个带有标准化自变量的新数据集<code>wine_standardized</code>。最后再次进行线性回归，并查看一下摘要统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependent_variable = wine[<span class="string">'quality'</span>]</span><br><span class="line">independent_variables = wine[wine.columns.difference([<span class="string">'quality'</span>, <span class="string">'type'</span>,\</span><br><span class="line"><span class="string">'in_sample'</span>])]</span><br><span class="line"></span><br><span class="line">independent_variables_standardized = (independent_variables -\</span><br><span class="line">independent_variables.mean()) / independent_variables.std()</span><br><span class="line"></span><br><span class="line">wine_standardized = pd.concat([dependent_variable, independent_variables\</span><br><span class="line">_standardized], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">lm_standardized = ols(my_formula, data=wine_standardized).fit()</span><br><span class="line">print(lm_standardized.summary())</span><br></pre></td></tr></table></figure><pre><code>                            OLS Regression Results                            ==============================================================================Dep. Variable:                quality   R-squared:                       0.292Model:                            OLS   Adj. R-squared:                  0.291Method:                 Least Squares   F-statistic:                     243.3Date:                Thu, 09 Nov 2017   Prob (F-statistic):               0.00Time:                        08:36:32   Log-Likelihood:                -7215.5No. Observations:                6497   AIC:                         1.445e+04Df Residuals:                    6485   BIC:                         1.454e+04Df Model:                          11                                         Covariance Type:            nonrobust                                         ========================================================================================                           coef    std err          t      P&gt;|t|      [0.025      0.975]----------------------------------------------------------------------------------------Intercept                5.8184      0.009    637.785      0.000       5.800       5.836alcohol                  0.3185      0.020     15.963      0.000       0.279       0.358chlorides               -0.0169      0.012     -1.454      0.146      -0.040       0.006citric_acid             -0.0159      0.012     -1.377      0.168      -0.039       0.007density                 -0.1648      0.036     -4.529      0.000      -0.236      -0.093fixed_acidity            0.0877      0.020      4.346      0.000       0.048       0.127free_sulfur_dioxide      0.1060      0.013      7.948      0.000       0.080       0.132pH                       0.0706      0.015      4.861      0.000       0.042       0.099residual_sugar           0.2072      0.025      8.449      0.000       0.159       0.255sulphates                0.1143      0.011     10.092      0.000       0.092       0.137total_sulfur_dioxide    -0.1402      0.016     -8.969      0.000      -0.171      -0.110volatile_acidity        -0.2186      0.013    -17.162      0.000      -0.244      -0.194==============================================================================Omnibus:                      144.075   Durbin-Watson:                   1.646Prob(Omnibus):                  0.000   Jarque-Bera (JB):              324.712Skew:                          -0.006   Prob(JB):                     3.09e-71Kurtosis:                       4.095   Cond. No.                         9.61==============================================================================</code></pre><h2 id="（六）预测"><a href="#（六）预测" class="headerlink" title="（六）预测"></a>（六）预测</h2><p>  在某些情况下，我们需要使用没有用来拟合模型的新数据进行预测。例如，你会收到关于葡萄酒成分的一个新观测，并需要根据这些成分预测这种葡萄酒的质量评分。下面使用葡萄酒数据集中的前10个观测创建10个“新”观测（只包含模型中使用的自变量），接着基于新观测中的葡萄酒特性预测质量评分，并将预测值打印到屏幕上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_observations = wine.ix[wine.index.isin(range(<span class="number">10</span>)), \</span><br><span class="line">independent_variables.columns]</span><br><span class="line">y_predicted = lm.predict(new_observations)</span><br><span class="line">y_predicted_rounded = [round(score, <span class="number">2</span>) <span class="keyword">for</span> score <span class="keyword">in</span> y_predicted]</span><br><span class="line">print(y_predicted_rounded)</span><br></pre></td></tr></table></figure><pre><code>[5.0, 4.92, 5.03, 5.68, 5.0, 5.04, 5.02, 5.30, 5.24, 5.69]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  本篇博文是作者在阅读完&lt;em&gt;Foundations for Analytics with Python&lt;/em&gt;一书后，使用Python进行数据分析的一次实战，所用数据集为&lt;a href=&quot;https://github.com/gaiusyao/pivotlab/bl
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python数据分析" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
      <category term="牛刀小试" scheme="http://gaiusyao.cn/tags/%E7%89%9B%E5%88%80%E5%B0%8F%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python基础06：类</title>
    <link href="http://gaiusyao.cn/2017/10/30/class/"/>
    <id>http://gaiusyao.cn/2017/10/30/class/</id>
    <published>2017-10-30T05:53:27.000Z</published>
    <updated>2018-01-10T05:30:34.989Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>面向对象编程</strong>是最有效的软件编写方法之一。而理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。在面向对象编程中，需要编写表示现实世界中的事物和情景的<strong>类</strong>，并基于这些类来创建对象。</p><h2 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h2><h3 id="创建Dog类"><a href="#创建Dog类" class="headerlink" title="创建Dog类"></a>创建Dog类</h3><p>  使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类Dog——它表示的不是特定的小狗，而是任何小狗。根据Dog类创建的每个实例都将存储名字和年龄，且赋予了每条小狗蹲下（sit()）和打滚（roll_over()）的能力：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    <span class="string">""</span><span class="string">"一次模拟小狗的简单尝试"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化属性name和age"</span><span class="string">""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def sit(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"模拟小狗被命令时蹲下"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"&#123;0&#125; is now sitting."</span>.format(self.name.title()))</span><br><span class="line"></span><br><span class="line">    def roll_over(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"模拟小狗被命令时打滚"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"&#123;0&#125; rolled over!"</span>.format(self.name.title()))</span><br></pre></td></tr></table></figure></p><p>  在第1行，定义了一个名为Dog（注意首字母需大写）的类。第2行，按惯例是一个文档字符串。再下面则是三个<strong>方法</strong>（类中的函数称为方法）。其中方法<code>__init__()</code>是一个特殊的方法，每当根据Dog类创建新实例时，Python都会自动运行它，而<code>__init__()</code>中有一个特殊的形参<code>self</code>，是一个指向实例本身的引用，让实例能够访问类中的属性和方法。而<code>sit</code>()和<code>roll_over()</code>两个方法则负责实现小狗蹲下和打滚动作，由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参<code>self</code>。</p><h3 id="根据类创建实例"><a href="#根据类创建实例" class="headerlink" title="根据类创建实例"></a>根据类创建实例</h3><p>  根据类来创建对象被称为<strong>实例化</strong>，下面根据Dog类来创建一个表示特定小狗的实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">'willie'</span>, 6)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"My dog's name is &#123;0&#125;."</span>.format(my_dog.name.title()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"My dog is &#123;0&#125; years old."</span>.format(str(my_dog.age)))</span><br><span class="line">my_dog.sit()</span><br><span class="line"><span class="comment"># My dog's name is Willie.</span></span><br><span class="line"><span class="comment"># My dog is 6 years old.</span></span><br><span class="line"><span class="comment"># Willie is now sitting.</span></span><br></pre></td></tr></table></figure></p><h2 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a>使用类和实例</h2><h3 id="Car类"><a href="#Car类" class="headerlink" title="Car类"></a>Car类</h3><p>  下面来编写一个表示汽车的类，它存储了有关汽车的信息，还有一个汇总这些信息的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Car():</span><br><span class="line">    <span class="string">""</span><span class="string">"一次模拟汽车的简单尝试"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化描述汽车的属性"</span><span class="string">""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line">    def get_descriptive_name(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"返回整洁的描述性信息"</span><span class="string">""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="built_in">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, 2016)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())    </span><br><span class="line"><span class="comment"># 2016 Audi A4</span></span><br></pre></td></tr></table></figure></p><h3 id="给属性指定默认值"><a href="#给属性指定默认值" class="headerlink" title="给属性指定默认值"></a>给属性指定默认值</h3><p>  类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<strong>init</strong>()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。下面来添加一个名为<code>odometer_reading</code>的属性，其初始值总是为0。我们还添加了一个名为<code>read_odometer()</code>的方法，用于读取汽车的里程表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Car():</span><br><span class="line">    <span class="string">""</span><span class="string">"一次模拟汽车的简单尝试"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化描述汽车的属性"</span><span class="string">""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = 0</span><br><span class="line"></span><br><span class="line">    def get_descriptive_name(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"返回整洁的描述性信息"</span><span class="string">""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="built_in">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    def read_odometer(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"打印一条指出汽车里程的消息"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>, <span class="string">'a4'</span>, 2016)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()    </span><br><span class="line"><span class="comment"># 2016 Audi A4</span></span><br><span class="line"><span class="comment"># This car has 0 miles on it.</span></span><br></pre></td></tr></table></figure></p><h3 id="修改属性值"><a href="#修改属性值" class="headerlink" title="修改属性值"></a>修改属性值</h3><p>  可以以三种不同的方式修改属性的值，下面以修改<code>odometer_reading</code>的值为例：</p><ol><li>直接通过实例进行修改：<code>my_new_car.odometer_reading = 23</code>；</li><li><p>通过方法进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def update_odometer(self, mileage):</span><br><span class="line">    <span class="string">""</span><span class="string">"将里程表读数设置为指定的值"</span><span class="string">""</span></span><br><span class="line">    self.odometer_reading = mileage</span><br></pre></td></tr></table></figure></li><li><p>通过方法进行递增（增加特定的值）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def increment_odometer(self, miles):</span><br><span class="line">    <span class="string">""</span><span class="string">"将里程表读数增加指定的量"</span><span class="string">""</span></span><br><span class="line">    self.odometer_reading += miles</span><br></pre></td></tr></table></figure></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承简介"><a href="#继承简介" class="headerlink" title="继承简介"></a>继承简介</h3><p>  编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用<strong>继承</strong>。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为<strong>父类</strong>，而新类称为<strong>子类</strong>。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。当然，一个语言如果没有支持继承特性不值得称作“类”。子类定义的语法如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(BaseClassName):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p><h3 id="子类的方法init"><a href="#子类的方法init" class="headerlink" title="子类的方法init()"></a>子类的方法<strong>init</strong>()</h3><p>  创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法<strong>init</strong>()需要父类施以援手。下面以<code>Car</code>的子类<code>ElectricCar</code>为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Car():</span><br><span class="line">    <span class="string">""</span><span class="string">"一次模拟汽车的简单尝试"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化描述汽车的属性"</span><span class="string">""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = 0</span><br><span class="line"></span><br><span class="line">    def get_descriptive_name(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"返回整洁的描述性信息"</span><span class="string">""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="built_in">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    def read_odometer(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"打印一条指出汽车里程的消息"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line"></span><br><span class="line">    def update_odometer(self, mileage):</span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line"></span><br><span class="line">    def increment_odometer(self, miles):</span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line">class ElectricCar(Car):</span><br><span class="line">    <span class="string">""</span><span class="string">"电动汽车的独特之处"</span><span class="string">""</span> </span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化父类的属性"</span><span class="string">""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, 2016)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())   </span><br><span class="line"><span class="comment"># 2016 Tesla Model S</span></span><br></pre></td></tr></table></figure></p><p>  这里有几点需要注意的：首先是创建子类时，父类必须包含在当前文件中，且位于子类前面。其次。定义子类时，必须在括号内指定父类的名称。方法<strong>init</strong>()接受创建Car实例所需的信息。而<code>super().__init__(make, model, year)</code>的<code>super()</code>是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法<strong>init</strong>()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。</p><h3 id="给子类定义属性和方法"><a href="#给子类定义属性和方法" class="headerlink" title="给子类定义属性和方法"></a>给子类定义属性和方法</h3><p>  让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。下面来添加一个电动汽车特有的属性（电瓶），以及一个描述该属性的方法。我们将存储电瓶容量，并编写一个打印电瓶描述的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ElectricCar(Car):</span><br><span class="line">    <span class="string">""</span><span class="string">"电动汽车的独特之处"</span><span class="string">""</span> </span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化父类的属性，再初始化电动汽车特有的属性"</span><span class="string">""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery_size = 70</span><br><span class="line"></span><br><span class="line">    def describe_battery(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"打印一条描述电瓶容量的消息"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, 2016)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br><span class="line"><span class="comment"># 2016 Tesla Model S</span></span><br><span class="line"><span class="comment"># This car has a 70-kWh battery.</span></span><br></pre></td></tr></table></figure></p><h3 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h3><p>  对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p><h3 id="将实例用作属性"><a href="#将实例用作属性" class="headerlink" title="将实例用作属性"></a>将实例用作属性</h3><p>  使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。我们将存储电瓶容量，并编写一个打印电瓶描述的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Battery():</span><br><span class="line">    <span class="string">""</span><span class="string">"一次模拟电动汽车电瓶的简单尝试"</span><span class="string">""</span></span><br><span class="line">    def __init__(self, battery_size=70):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化电瓶的属性"</span><span class="string">""</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">    def describe_battery(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"打印一条描述电瓶容量的消息"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"></span><br><span class="line">class ElectricCar(Car):</span><br><span class="line">    <span class="string">""</span><span class="string">"电动汽车的独特之处"</span><span class="string">""</span> </span><br><span class="line"></span><br><span class="line">    def __init__(self, make, model, year):</span><br><span class="line">        <span class="string">""</span><span class="string">"初始化父类的属性，再初始化电动汽车特有的属性"</span><span class="string">""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br><span class="line"></span><br><span class="line">    def describe_battery(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"打印一条描述电瓶容量的消息"</span><span class="string">""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'model s'</span>, 2016)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line"><span class="comment"># 2016 Tesla Model S</span></span><br><span class="line"><span class="comment"># This car has a 70-kWh battery.</span></span><br></pre></td></tr></table></figure></p><h2 id="导入类"><a href="#导入类" class="headerlink" title="导入类"></a>导入类</h2><ul><li>导入单个类：<code>from module_name import ClassName</code></li><li>导入多个类：<code>from module_name import ClassZero, ClassOne</code></li><li>导入所有类：<code>from module_name import *</code></li><li>导入整个模块：<code>import module_name</code></li></ul><h2 id="Pytho标准库"><a href="#Pytho标准库" class="headerlink" title="Pytho标准库"></a>Pytho标准库</h2><p>  Python标准库是一组模块，安装的Python都包含它。在程序开头包含一条简单的import语句，即可使用标准库中的任何函数和类。例如通过<code>from collections import OrderedDict</code>导入模块collections中的OrderedDict类，以创建记录了键—值对的添加顺序的字典：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">favorite_languages = OrderedDict()</span><br><span class="line"></span><br><span class="line">favorite_languages[<span class="string">'jen'</span>] = <span class="string">'python'</span></span><br><span class="line">favorite_languages[<span class="string">'sarah'</span>] = <span class="string">'c'</span></span><br><span class="line">favorite_languages[<span class="string">'edward'</span>] = <span class="string">'ruby'</span></span><br><span class="line">favorite_languages[<span class="string">'phil'</span>] = <span class="string">'python'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, language <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"&#123;0&#125;'s favorite language is &#123;1&#125;."</span>.format(name.title(), language.title()))</span><br></pre></td></tr></table></figure></p><h2 id="编写类注意事项"><a href="#编写类注意事项" class="headerlink" title="编写类注意事项"></a>编写类注意事项</h2><ul><li>类名应采用<strong>驼峰命名法</strong>，即将类名中的每个单词的首字母都大写，其余小写，且不使用下划线；</li><li>实例名和模块名都采用小写格式，并在单词之间加上下划线；</li><li>类定义后面需包含一个文档字符串，简要地描述类的功能；</li><li>在类中使用一个空行来分隔方法，而在模块中则使用两个空行来分隔类；</li><li>用空行分隔导入标准库中的模块和自己编写的模块。</li></ul><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  &lt;strong&gt;面向对象编程&lt;/strong&gt;是最有效的软件编写方法之一。而理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。在面向对象编程中，需要编写表示现实世界中的事物和情景的&lt;stron
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Python基础05：函数</title>
    <link href="http://gaiusyao.cn/2017/10/30/functions/"/>
    <id>http://gaiusyao.cn/2017/10/30/functions/</id>
    <published>2017-10-30T03:03:45.000Z</published>
    <updated>2018-01-10T05:31:04.641Z</updated>
    
    <content type="html"><![CDATA[<p>  可以将函数理解为带名字的代码块，用于被反复调用以完成具体的工作。函数的使用，极大地减少了重复代码的出现，提升了代码的可复用性，让程序的编写、阅读、测试和修复都变得更容易。</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>  通过关键字<code>def</code>引入函数的定义。它必须后跟函数名和形式参数的括号列表。形成函数体的语句从下一行开始，必须缩进。下面定义了一个函数，用以将<strong>Fibonacci</strong>序列写入任意边界：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    <span class="string">""</span><span class="string">"打印一个Fibonacci序列"</span><span class="string">""</span></span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(a, end = <span class="string">' '</span>)</span><br><span class="line">        a, b = b, a+b</span><br></pre></td></tr></table></figure></p><p>  第1行代码是<strong>函数定义</strong>，向Python指出了函数名，还可能在括号内指出函数为完成其任务需要什么样的信息。第2行的文本是被称为<strong>文档字符串</strong>（docstring）的注释，描述了函数是做什么的，由三引号括起，Python使用它来生成有关程序中函数的文档。第3至第6行则是具体的执行代码，负责打印一个Fibonacci序列。</p><h3 id="向函数传递信息"><a href="#向函数传递信息" class="headerlink" title="向函数传递信息"></a>向函数传递信息</h3><p>  通过在定义函数fib()添加一个变量<code>n</code>，就可让函数接受你给<code>n</code>指定的任何值，使得调用<code>fib(n)</code>时可以给<code>n</code>指定一个值，从而生成相应的输出，下面的代码将会打印一个Fibonacci序列：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fib(2000)</span><br><span class="line"><span class="comment">#0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</span></span><br></pre></td></tr></table></figure></p><h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><p>  在前面定义的函数fib()中，变量<code>n</code>是一个形参——函数完成其工作所需的一项信息。在代码<code>fib(2000)</code>中，值<code>2000</code>是一个实参——调用函数时传递给函数的信息。在<code>fib(2000)</code>中，将实参<code>2000</code>传递给了函数fib()，这个值被存储在形参<code>n</code>中，由此得到想要的结果。</p><h2 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h2><h3 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h3><p>  在调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为<strong>位置实参</strong>。下面是一个显示宠物信息的函数,这个函数指出一个宠物属于哪种动物以及它叫什么名字，在调用它时，需要按顺序提供位置实参数（一种动物类型和一个名字），如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def describe_pet(animal_type, pet_name):</span><br><span class="line">    <span class="string">""</span><span class="string">"显示宠物的信息"</span><span class="string">""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have a &#123;0&#125;."</span>.format(animal_type))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My &#123;0&#125;'s name is &#123;1&#125;."</span>.format(animal_type, pet_name.title()))</span><br><span class="line">   </span><br><span class="line">describe_pet(<span class="string">'hamster'</span>, <span class="string">'harry'</span>) </span><br><span class="line"><span class="comment"># I have a hamster.</span></span><br><span class="line"><span class="comment"># My hamster's name is Harry.</span></span><br></pre></td></tr></table></figure></p><h3 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h3><p>  <strong>关键字实参</strong>是传递给函数的名称—值对，直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。重写5.2.1的代码，使用关键字实参来调用describe_pet()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(pet_name=<span class="string">'harry'</span>, animal_type=<span class="string">'hamster'</span>)</span><br><span class="line"><span class="comment"># I have a hamster.</span></span><br><span class="line"><span class="comment"># My hamster's name is Harry.</span></span><br></pre></td></tr></table></figure></p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>  编写函数时，可给每个形参指定<strong>默认值</strong>。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。重写5.2.1的代码，形参<code>animal_type</code>的默认值设置为<code>&#39;dog&#39;</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def describe_pet(pet_name, animal_type=<span class="string">'dog'</span>):</span><br><span class="line">    <span class="string">""</span><span class="string">"显示宠物的信息"</span><span class="string">""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have a &#123;0&#125;."</span>.format(animal_type))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My &#123;0&#125;'s name is &#123;1&#125;."</span>.format(animal_type, pet_name.title()))</span><br><span class="line">describe_pet(pet_name=<span class="string">'willie'</span>)</span><br><span class="line"><span class="comment"># I have a dog.</span></span><br><span class="line"><span class="comment"># My hamster's name is Willie.</span></span><br></pre></td></tr></table></figure></p><p>  上述三种调用方式基本等效，因此使用哪种无关紧要，只要函数调用能生成你希望的输出就行。但要注意避免<strong>实参不匹配错误</strong>，即提供的实参多于或少于函数完成其工作所需的信息。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><h3 id="返回简单值"><a href="#返回简单值" class="headerlink" title="返回简单值"></a>返回简单值</h3><p>  下面来看一个函数，它接受名和姓两个参数，并返回一个简单值（一个整洁的姓名）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回整洁的姓名"</span><span class="string">""</span></span><br><span class="line">    full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="built_in">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"><span class="comment"># Jimi Hendrix</span></span><br></pre></td></tr></table></figure></p><h3 id="可选实参"><a href="#可选实参" class="headerlink" title="可选实参"></a>可选实参</h3><p>  有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。例如，假设我们要扩展5.3.1的函数<code>get_formatted_name()</code>，使其还能处理中间名（如果有）。为此，可将中间名放在最后，且默认为空，修改后如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name, middle_name=<span class="string">''</span>):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回整洁的姓名"</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + middle_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="built_in">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"><span class="comment"># Jimi Hendrix</span></span><br><span class="line">musician = get_formatted_name(<span class="string">'john'</span>, <span class="string">'lee'</span>, <span class="string">'hooker'</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"><span class="comment"># John Hooker Lee</span></span><br></pre></td></tr></table></figure></p><h3 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h3><p>  函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def build_person(first_name, last_name):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回一个字典，其中包含有关一个人的信息"</span><span class="string">""</span></span><br><span class="line">    person = &#123;<span class="string">'first'</span>: first_name, <span class="string">'last'</span>: last_name&#125;</span><br><span class="line">    <span class="built_in">return</span> person</span><br><span class="line"></span><br><span class="line">musician = build_person(<span class="string">'jimi'</span>, <span class="string">'hendrix'</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br></pre></td></tr></table></figure></p><h3 id="结合while循环"><a href="#结合while循环" class="headerlink" title="结合while循环"></a>结合while循环</h3><p>  结合while循环，以更正规的方式问候用户，直到用户输入的姓或名为’q’为止：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def get_formatted_name(first_name, last_name, middle_name=<span class="string">''</span>):</span><br><span class="line">    <span class="string">""</span><span class="string">"返回整洁的姓名"</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + middle_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">' '</span> + last_name</span><br><span class="line">    <span class="built_in">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nPlease tell me your name:"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(enter 'q' at any time to quit)"</span>)</span><br><span class="line"></span><br><span class="line">    f_name = input(<span class="string">"First name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> f_name == <span class="string">'q'</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">    l_name = input(<span class="string">"Last name: "</span>)</span><br><span class="line">    <span class="keyword">if</span> l_name == <span class="string">'q'</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">    formatted_name = get_formatted_name(f_name, l_name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nHello, "</span> + formatted_name + <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="传递列表"><a href="#传递列表" class="headerlink" title="传递列表"></a>传递列表</h2><p>  向函数传递列表非常有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。下面的示例将一个名字列表传递给一个名为<code>greet_users()</code>的函数，这个函数问候列表中的每个人：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def greet_users(names):</span><br><span class="line">    <span class="string">""</span><span class="string">"向列表中的每位用户都发出简单的问候"</span><span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Hello, &#123;0&#125;!"</span>.format(name.title()))</span><br><span class="line"></span><br><span class="line">usernames = [<span class="string">'hannah'</span>, <span class="string">'ty'</span>, <span class="string">'margot'</span>]</span><br><span class="line">greet_users(usernames)</span><br><span class="line"><span class="comment"># Hello, Hannah!</span></span><br><span class="line"><span class="comment"># Hello, Ty!</span></span><br><span class="line"><span class="comment"># Hello, Margot!</span></span><br></pre></td></tr></table></figure></p><h2 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h2><p>  有时候，预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。下面的函数包含了两个形参，其中第二个形参<code>*toppings</code>中的<code>*</code>让Python创建一个名为<code>toppings</code>的空元组，但不管调用语句为第二个形参提供了多少实参，<code>*toppings</code>都将它们统统收入囊中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def make_pizza(size, *toppings):</span><br><span class="line">    <span class="string">""</span><span class="string">"概述要制作的比萨"</span><span class="string">""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nMaking a &#123;0&#125;-inch pizza with the following toppings:"</span>.format(str(size)))</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"- &#123;0&#125;"</span>.format(topping))</span><br><span class="line"></span><br><span class="line">make_pizza(16, <span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(12, <span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p><p>  有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。在下面的示例中，函数<code>build_profile()</code>接受名和姓，同时还接受任意数量的关键字实参。其中，<code>**user_info</code>创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def build_profile(first, last, **user_info):</span><br><span class="line">    <span class="string">""</span><span class="string">"创建一个字典，其中包含我们知道的有关用户的一切"</span><span class="string">""</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">'first_name'</span>] = first</span><br><span class="line">    profile[<span class="string">'last_name'</span>] = last </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="built_in">return</span> profile</span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">'albert'</span>, <span class="string">'einstein'</span>, location=<span class="string">'princeton'</span>, field=<span class="string">'physics'</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br></pre></td></tr></table></figure></p><h2 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h2><p>  函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。<strong>import语句</strong>允许在当前运行的程序文件中使用模块中的代码。导入方式主要有以下几种：</p><ul><li>导入整个模块：<code>import module_name</code></li><li>导入模块中所有函数：<code>from module_name import *</code></li><li>导入特定的函数：<code>from module_name import function_0, function_1, function_2</code><br>  此外，可以通过<strong>as语句</strong>为导入的模块或函数命名：</li><li>为导入模块命名：<code>import module_name as mn</code></li><li>为导入函数命名：<code>from module_name import function_name as fn</code></li></ul><h2 id="函数编写注意事项"><a href="#函数编写注意事项" class="headerlink" title="函数编写注意事项"></a>函数编写注意事项</h2><p>  编写函数时，需要牢记几个细节：</p><ul><li>应给函数指定描述性名称，且只在其中使用小写字母和下划线；</li><li>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式；</li><li>给形参指定默认值时，等号两边不要有空格：<code>def function_name(parameter_0, parameter_1=&#39;default value&#39;)</code>；</li><li>对于函数调用中的关键字实参，也应遵循这种约定：<code>function_name(value_0, parameter_1=&#39;value&#39;)</code>；</li><li>所有的import语句都应放在文件开头的文档注释后。</li></ul><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  可以将函数理解为带名字的代码块，用于被反复调用以完成具体的工作。函数的使用，极大地减少了重复代码的出现，提升了代码的可复用性，让程序的编写、阅读、测试和修复都变得更容易。&lt;/p&gt;
&lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;header
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Python基础04：控制流</title>
    <link href="http://gaiusyao.cn/2017/10/29/control-flow/"/>
    <id>http://gaiusyao.cn/2017/10/29/control-flow/</id>
    <published>2017-10-29T02:17:07.000Z</published>
    <updated>2018-01-10T05:30:16.861Z</updated>
    
    <content type="html"><![CDATA[<p>  目前为止，除了简单地使用过if语句和for循环以外，Python都是按从上到下的顺序执行语句。如果想要让程序根据不同的情况做不同的事情，例如根据条件执行语句或循环语句，则需要用到控制流。这里介绍三种常见的控制流语句————if、for和while。</p><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><h3 id="一个if语句的简单示例"><a href="#一个if语句的简单示例" class="headerlink" title="一个if语句的简单示例"></a>一个if语句的简单示例</h3><p>  下面是一个简短的示例，演示了如何使用if语句来正确地处理特殊情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avengers = [<span class="string">'iron man'</span>, <span class="string">'captain america'</span>, <span class="string">'hulk'</span>, <span class="string">'thor'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #1: "</span>)</span><br><span class="line"><span class="keyword">for</span> avenger <span class="keyword">in</span> avengers:</span><br><span class="line">    <span class="keyword">if</span> avenger == <span class="string">'iron man'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t&#123;0&#125; is very rich."</span>.format(avenger.title()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t&#123;0&#125; has no money."</span>.format(avenger.title()))</span><br></pre></td></tr></table></figure></p><p>  在这个示例中，循环首先检查当前的复仇者是否<code>&#39;iron man&#39;</code>，如果是，则打印if下的相应语句，否则则执行else下的语句。从中我们可以看到，每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为<strong>条件测试</strong>。Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。如果条件测试的值为True，Python就执行紧跟在if语句后面的代码；如果为False，Python就忽略这些代码。</p><h3 id="检查是否相等"><a href="#检查是否相等" class="headerlink" title="检查是否相等"></a>检查是否相等</h3><p>  大多数条件测试都将一个变量的当前值同特定值进行比较。最简单的条件测试检查变量的值是否与特定值相等：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iron_man = <span class="string">'tony stark'</span></span><br><span class="line">iron_man == <span class="string">'tony stark'</span> <span class="comment">#相等，返回True</span></span><br><span class="line">iron_man == <span class="string">'bruce wayne'</span> <span class="comment">#不等，返回False</span></span><br></pre></td></tr></table></figure></p><h3 id="检查是否相等时区分大小写"><a href="#检查是否相等时区分大小写" class="headerlink" title="检查是否相等时区分大小写"></a>检查是否相等时区分大小写</h3><p>  在Python中检查是否相等时区分大小写，例如，两个大小写不同的值会被视为不相等：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iron_man = <span class="string">'Tony Stark'</span></span><br><span class="line">iron_man == <span class="string">'tony stark'</span> <span class="comment">#不等，返回False</span></span><br></pre></td></tr></table></figure></p><p>  但如果大小写无关紧要，而只想检查变量的值，可借助前面用到过的lower()将变量的值转换为小写，再进行比较。</p><h3 id="检查是否不相等"><a href="#检查是否不相等" class="headerlink" title="检查是否不相等"></a>检查是否不相等</h3><p>  要判断两个值是否不等，可结合使用惊叹号和等号<code>!=</code>，其中的惊叹号表示不，在很多其他的编程语言中都如此：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requested_topping = <span class="string">'mushrooms'</span></span><br><span class="line"><span class="keyword">if</span> requested_topping != <span class="string">'anchovies'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #2: Hold the anchovies!"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="检查数值"><a href="#检查数值" class="headerlink" title="检查数值"></a>检查数值</h3><p>  检查数值非常简单，例如，下面的代码检查答案是否是<strong>42</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">answer = 13</span><br><span class="line"><span class="keyword">if</span> answer != 42:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #3: That is not the ultlimate answer!!!"</span>)</span><br></pre></td></tr></table></figure></p><p>  条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">answer = 42</span><br><span class="line">answer &lt; 69 <span class="comment">#True</span></span><br><span class="line">answer &gt; 69 <span class="comment">#False</span></span><br><span class="line">answer &gt;= 30 <span class="comment">#True</span></span><br><span class="line">answer &lt;= 83 <span class="comment">#True</span></span><br></pre></td></tr></table></figure></p><h3 id="检查多个条件"><a href="#检查多个条件" class="headerlink" title="检查多个条件"></a>检查多个条件</h3><p>  有的时候同时检查多个条件，例如，有时候你需要在两个条件都为True时才执行相应的操作，而有时候你只要求其中一个条件为True时就执行相应的操作。在这些情况下，关键字<code>and</code>和<code>or</code>可助你一臂之力：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age_0 = 22</span><br><span class="line">age_1 = 18</span><br><span class="line">age_0 &gt;= 21 and age_1 &gt;= 21 <span class="comment">#False</span></span><br><span class="line">age_0 &gt;= 21 or age_1 &gt;= 21 <span class="comment">#True</span></span><br></pre></td></tr></table></figure></p><h3 id="检查特定值是否包含在列表中"><a href="#检查特定值是否包含在列表中" class="headerlink" title="检查特定值是否包含在列表中"></a>检查特定值是否包含在列表中</h3><p>  有时候，执行操作前必须检查列表是否包含特定的值。要判断特定的值是否已包含在列表中，可使用关键字in。来看为比萨店编写的一些代<br>码；这些代码首先创建一个列表，其中包含用户点的比萨配料，然后检查特定的配料是否包含在该列表中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'onions'</span>, <span class="string">'pineapple'</span>]</span><br><span class="line"><span class="string">'mushrooms'</span> <span class="keyword">in</span> requested_toppings <span class="comment">#True</span></span><br><span class="line"><span class="string">'pepperoni'</span> <span class="keyword">in</span> requested_toppings <span class="comment">#False</span></span><br></pre></td></tr></table></figure></p><h3 id="检查特定值是否不包含在列表中"><a href="#检查特定值是否不包含在列表中" class="headerlink" title="检查特定值是否不包含在列表中"></a>检查特定值是否不包含在列表中</h3><p>  还有些时候，确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字not in：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banned_users = [<span class="string">'andrew'</span>, <span class="string">'carolina'</span>, <span class="string">'david'</span>]</span><br><span class="line">user = <span class="string">'marie'</span></span><br><span class="line"><span class="keyword">if</span> user not <span class="keyword">in</span> banned_users:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #4: &#123;0&#125;, you can post a response if you wish."</span>.format(user.title()))</span><br></pre></td></tr></table></figure></p><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><p>  <strong>布尔表达式</strong>，它不过是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为True，要么为False。；布尔值通常用于记录条件，如用户是否有相关权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_edit = False</span><br></pre></td></tr></table></figure></p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><h3 id="if语句简介"><a href="#if语句简介" class="headerlink" title="if语句简介"></a>if语句简介</h3><p>  正如前面看到的，if语句用来检验一个条件，常与else从句搭配使用，如果条件测试结果为真(True)，我们运行一块语句(if代码块)，否则，我们处理另外一块语句(else代码块)。其中，else从句是可选的，将在下一部分介绍。<br>  最简单的if语句只有一个测试和一个操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conditional_test:</span><br><span class="line">    <span class="keyword">do</span> somethingcan_edit = False</span><br></pre></td></tr></table></figure></p><p>  假设有一个表示某人年龄的变量，而你想知道这个人是否够驾驶的年龄，可使用如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = 19</span><br><span class="line"><span class="keyword">if</span> age &gt;= 18:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #5: You are old enough to drive!"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>  经常需要在条件测试通过了时执行一个操作，并在没有通过时执行另一个操作；在这种情况下，就要用到<code>if-else</code>语句。<br>  下面的代码在一个人够驾驶的年龄时显示与前面相同的消息，同时在这个人不够驾驶的年龄时也显示一条消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = 16</span><br><span class="line"><span class="keyword">if</span> age &gt;= 18:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #6: You are old enough to drive!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #6: Sorry, you are too young to drive."</span>)</span><br></pre></td></tr></table></figure></p><h3 id="if-elif-else结构"><a href="#if-elif-else结构" class="headerlink" title="if-elif-else结构"></a>if-elif-else结构</h3><p>  当需要检查的条件超过两个的时候，<code>if-else</code>就明显不够用了，此时就需要借助<code>if-elif-else</code>结构，它依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python将执行紧跟在它后面的代码，并跳过余下的测试，如下例所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 91</span><br><span class="line"><span class="keyword">if</span> age &gt;= 18 and age &lt; 70:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #7: You are old enough to drive!"</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= 70:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #7: Sorry, you are too old to drive."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nOutput #7: Sorry, you are too young to drive."</span>)</span><br></pre></td></tr></table></figure></p><p>  可根据需要使用任意数量的elif代码块，另外也可以省略else代码块，代之以用一条elif语句来处理。</p><h3 id="测试多个条件"><a href="#测试多个条件" class="headerlink" title="测试多个条件"></a>测试多个条件</h3><p>  <code>if-elif-else</code>结构功能强大，但仅适合用于只有一个条件满足的情况：遇到通过了的测试后，Python就跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含elif和else代码块的简单if语句。在可能有多个条件为True，且你需要在每个条件为True时都采取相应措施时，适合使用这种方法。下面再来看前面的比萨店示例。如果顾客点了两种配料，就需要确保在其比萨中包含这些配料：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #8: "</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'mushrooms'</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tAdding mushrooms."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'pepperoni'</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tAdding pepperoni."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'extra cheese'</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tAdding extra cheese."</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Finished making your pizza!"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="使用if语句处理列表"><a href="#使用if语句处理列表" class="headerlink" title="使用if语句处理列表"></a>使用if语句处理列表</h3><p>  可以用if语句检查列表中的特殊值，例如比萨店的青椒用完了，需要检查顾客点的是否是青椒，如果是，就打印一条消息，说明不能点青椒的原因。可在for循环中包含一条if语句完成上述工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #9: "</span>)</span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping == <span class="string">'green peppers'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\tSorry, we are out of green peppers right now."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\tAdding &#123;0&#125;."</span>.format(requested_topping))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Finished making your pizza!"</span>)</span><br></pre></td></tr></table></figure></p><p>  同样的，可以利用if语句检查列表是否为空：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #10: "</span>)</span><br><span class="line"><span class="keyword">if</span> requested_toppings:</span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\tAdding &#123;0&#125;."</span>.format(requested_topping))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Finished making your pizza!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Are you sure you want a plain pizza?"</span>)</span><br></pre></td></tr></table></figure></p><p>  事实上，我们经常需要同时使用多个列表，这会让结构变得稍微复杂一点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">available_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'olives'</span>, <span class="string">'green peppers'</span>, <span class="string">'pepperoni'</span>, <span class="string">'pineapple'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line">requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'french fries'</span>, <span class="string">'extra cheese'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #11: "</span>)</span><br><span class="line"><span class="keyword">if</span> requested_toppings:</span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        <span class="keyword">if</span> requested_topping <span class="keyword">in</span> available_toppings:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\tAdding &#123;0&#125;."</span>.format(requested_topping))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\tSorry, we don't have &#123;0&#125;."</span>.format(requested_topping))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Finished making your pizza!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Are you sure you want a plain pizza?"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="for循环详解"><a href="#for循环详解" class="headerlink" title="for循环详解"></a>for循环详解</h3><p>  在<a href="https://gaiusyao.github.io/2017/10/28/lists-tuples/" target="_blank" rel="noopener">02.列表和元组</a>我们第一次使用了<strong>for循环</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtles = [<span class="string">'Leonardo'</span>, <span class="string">'Raphael'</span>, <span class="string">'Michelangelo'</span>, <span class="string">'Donatello'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #12: "</span>)</span><br><span class="line"><span class="keyword">for</span> ninja_turtle <span class="keyword">in</span> ninja_turtles:</span><br><span class="line">    <span class="built_in">print</span>(ninja_turtle)</span><br></pre></td></tr></table></figure></p><p>  在上面代码构建的简单循环中，Python将首先读取其中的第一行代码<code>for ninja_turtle in ninja_turtles:</code><br>  这行代码让Python获取列表<code>ninja_turtles</code>中的第一个值（<code>&#39;Leonardo&#39;</code>），并将其存储到变量<code>ninja_turtle</code>中。接下来，Python读取下一行代码<code>print(ninja_turtle)</code>，它让Python打印<code>ninja_turtle</code>的值——依然是<code>&#39;Leonardo&#39;</code>。<br>  由于列表还包含着其他值，Python返回到循环的第一行<code>for ninja_turtle in ninja_turtles:</code><br>  Python再次打印<code>ninja_turtle</code>的值——这次是<code>&#39;Raphael&#39;</code>。接下来，Python继续前面的步骤，直到将列表中的最后一个值<code>&#39;Donatello&#39;</code>打印出来为止。而此时，列表中已经没有其他的值了，因此Python接着执行程序的下一行代码。<br>  对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python就重复执行指定的步骤一百万次，且通常速度非常快。另外，对于用于存储列表中每个值的临时变量，可指定任何名称，但使用有意义的名称可以提高代码的可读性。</p><h3 id="执行更多的操作"><a href="#执行更多的操作" class="headerlink" title="执行更多的操作"></a>执行更多的操作</h3><p>  在for循环中，可对每个元素执行任何操作，也可以在for循环结束后提供总结性输出或接着执行程序必须完成的其他任务。扩展之前的示例，对每位神龟都打印一条信息，指出他是一个忍者，并在最后指出他们的身份：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtles = [<span class="string">'Leonardo'</span>, <span class="string">'Raphael'</span>, <span class="string">'Michelangelo'</span>, <span class="string">'Donatello'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #13: "</span>)</span><br><span class="line"><span class="keyword">for</span> ninja_turtle <span class="keyword">in</span> ninja_turtles:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"&#123;0&#125; is a ninja."</span>.format(ninja_turtle))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"They\'re Ninja Turtles!"</span>)</span><br></pre></td></tr></table></figure></p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input()函数"></a>input()函数</h3><p>  在介绍<strong>while循环</strong>前，先让我们花几分钟，了解下input()函数。<br>  input()可以让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。下面的代码将会存储你输入的信息到<code>message</code>，并通过<code>print(message)</code>打印出来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = input(<span class="string">"Tell me something, and I will repeat it back to you: "</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></p><p>  可以通过input()获取用户的数值输入，但需要注意的是，Python将用户通过input()输入的值解读为字符串，这在将输入作为数字使用时，会引发错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">age = input(<span class="string">"How old are you? "</span>)</span><br><span class="line">age <span class="comment">#'42'</span></span><br><span class="line">age &gt;= 18</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br></pre></td></tr></table></figure></p><p>  这里需要借助int()函数将数字的字符串表示转换为数值表示，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = int(age)</span><br><span class="line">age &gt;= 18 <span class="comment">#True</span></span><br></pre></td></tr></table></figure></p><h3 id="while循环简介"><a href="#while循环简介" class="headerlink" title="while循环简介"></a>while循环简介</h3><p>  for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条件不满足为止。下面是一个while循环的简单示例，它将从1数到5：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current_number = 1</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #14: "</span>)</span><br><span class="line"><span class="keyword">while</span> current_number &lt;= 5:</span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br><span class="line">    current_number += 1</span><br></pre></td></tr></table></figure></p><p>  在第1行，我们将<code>current_number</code>设置为1，从而指定从1开始数。接下来的while循环被设成这样：只要c<code>urrent_number</code>小于或等于5，就接着运行这个循环。循环中的代码打印<code>current_number</code>的值，再使用代码<code>current_number += 1</code>（<code>current_number = current_number +1</code>的简写）将其值加1。只要满足条件<code>current_number &lt;= 5</code>，Python就接着运行这个循环。直到<code>current_number</code>大于5，循环将停止，整个程序也将到此结束。</p><h3 id="让用户选择何时退出"><a href="#让用户选择何时退出" class="headerlink" title="让用户选择何时退出"></a>让用户选择何时退出</h3><p>  可以让用户输入一个退出值（如<code>&#39;quit&#39;</code>），以选择何时退出循环：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">"Tell me something, and I will repeat it back to you:"</span></span><br><span class="line">prompt += <span class="string">"\nEnter 'quit' to end the program. "</span></span><br><span class="line">message = <span class="string">""</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #15: "</span>)</span><br><span class="line"><span class="keyword">while</span> message != <span class="string">'quit'</span>:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></p><h3 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h3><p>  在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为<strong>标志</strong>，充当了程序的交通信号灯。记得在条件测试提到的<strong>布伦表达式</strong>么？可以通过将布伦表达式作为<strong>标志</strong>。在标志为<code>True</code>时继续运行，并在任何事件导致标志的值为<code>False</code>时让程序停止运行。这样，在while语句中就只需检查一个条件——标志的当前值是否为<code>True</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">active = True</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #16: "</span>)</span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    message = input(prompt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">'quit'</span>:</span><br><span class="line">        active = False</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></p><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>  break语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。如在while循环中，想要立即退出，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用<strong>break语句</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #17: "</span>)</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    city = input(prompt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> city == <span class="string">'quit'</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'd love to go to &#123;0&#125;!"</span>.format(city.title()))</span><br></pre></td></tr></table></figure></p><p>  以<code>while True</code>打头的循环（见）将不断运行，直到遇到break语句。这个程序中的循环不断输入用户到过的城市的名字，直到输入<code>&#39;quit&#39;</code>为止。用户输入<code>&#39;quit&#39;</code>后，将执行break语句，导致Python退出循环。</p><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>  要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用<strong>continue语句</strong>，它不像break语句那样不再执行余下的代码并退出整个循环。例如，来看一个从1数到10，但只打印其中奇数的循环：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current_number = 0</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #18: "</span>)</span><br><span class="line"><span class="keyword">while</span> current_number &lt; 10:</span><br><span class="line">    current_number += 1</span><br><span class="line">    <span class="keyword">if</span> current_number % 2 == 0:</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br></pre></td></tr></table></figure></p><p>  首先将<code>current_number</code>设置成了0，由于它小于10，进入while循环。进入循环后，我们以步长1的方式往上数，因此<code>current_number</code>为1。接下来，if语句检查<code>current_number</code>与2的求模运算结果。如果结果为0（意味着<code>current_number</code>可被2整除），就执行continue语句，让Python忽略余下的代码，并返回到循环的开头。如果当前的数字不能被2整除，就执行循环中余下的代码，Python将这个数字打印出来。</p><h3 id="避免无限循环"><a href="#避免无限循环" class="headerlink" title="避免无限循环"></a>避免无限循环</h3><p>  每个while循环都必须有停止运行的途径，这样才不会没完没了地执行下去。例如，下面的循环将会无限循环：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br><span class="line"><span class="keyword">while</span> x &lt;= 5:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></p><p>  如果在测试中程序陷入无限循环，可按<strong>Ctrl + C</strong>，也可关闭显示程序输出的终端窗口。但在实际应用中出现无限循环，则会带来很大的麻烦，因此务必对每个while循环进行测试，确保它按预期那样结束，避免无限循环的出现。</p><h2 id="使用while-循环来处理列表和字典"><a href="#使用while-循环来处理列表和字典" class="headerlink" title="使用while 循环来处理列表和字典"></a>使用while 循环来处理列表和字典</h2><h3 id="在列表之间移动元素"><a href="#在列表之间移动元素" class="headerlink" title="在列表之间移动元素"></a>在列表之间移动元素</h3><p>  假设有一个列表，其中包含新注册但还未验证的网站用户；验证这些用户后，如何将他们移到另一个已验证用户列表中呢？一种办法是使用一个while循环，在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中。代码可能类似于下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，创建一个待验证用户列表和一个用于存储已验证用户的空列表</span></span><br><span class="line">unconfirmed_users = [<span class="string">'alice'</span>, <span class="string">'brian'</span>, <span class="string">'candace'</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #19: "</span>)</span><br><span class="line"><span class="comment"># 验证每个用户，直到没有未验证用户为止</span></span><br><span class="line"><span class="comment"># 将每个经过验证的列表都移到已验证用户列表中</span></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Verifying user: &#123;0&#125;"</span>.format(current_user.title()))</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有已验证的用户</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following users have been confirmed:"</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t&#123;0&#125;"</span>.format(confirmed_user.title()))</span><br></pre></td></tr></table></figure></p><h3 id="删除包含特定值的所有列表元素"><a href="#删除包含特定值的所有列表元素" class="headerlink" title="删除包含特定值的所有列表元素"></a>删除包含特定值的所有列表元素</h3><p>  在<a href="https://gaiusyao.github.io/2017/10/28/lists-tuples/" target="_blank" rel="noopener">02.列表和元组</a>，我们使用remove()函数来删除列表中的特定值。而结合while循环，可以删除列表中所有包含特定值的元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个宠物列表，其中包含多个值为'cat'的元素</span></span><br><span class="line">pets = [<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'cat'</span>, <span class="string">'rabbit'</span>, <span class="string">'cat'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #20 (original): "</span>.format(pets))</span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">'cat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #20 (removed): "</span>.format(pets))</span><br></pre></td></tr></table></figure></p><h3 id="使用用户输入来填充字典"><a href="#使用用户输入来填充字典" class="headerlink" title="使用用户输入来填充字典"></a>使用用户输入来填充字典</h3><p>  可使用while循环提示用户输入任意数量的信息，并将收集的数据存储在一个字典中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空字典</span></span><br><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个标志，指出调查是否继续</span></span><br><span class="line">polling_active = True</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    <span class="comment"># 提示输入被调查者的名字和回答</span></span><br><span class="line">    name = input(<span class="string">"\nWhat is your name? "</span>)</span><br><span class="line">    response = input(<span class="string">"Which mountain would you like to climb someday? "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将答卷存储在字典中</span></span><br><span class="line">    responses[name] = response</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 看看是否还有人要参与调查</span></span><br><span class="line">    repeat = input(<span class="string">"Would you like to let another person respond? (yes/ no) "</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">'no'</span>:</span><br><span class="line">        polling_active = False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调查结束，显示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nOutput #21: "</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    <span class="built_in">print</span>(name + <span class="string">" would like to climb "</span> + response + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure></p><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  目前为止，除了简单地使用过if语句和for循环以外，Python都是按从上到下的顺序执行语句。如果想要让程序根据不同的情况做不同的事情，例如根据条件执行语句或循环语句，则需要用到控制流。这里介绍三种常见的控制流语句————if、for和while。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Python基础03：字典</title>
    <link href="http://gaiusyao.cn/2017/10/28/dictionaries/"/>
    <id>http://gaiusyao.cn/2017/10/28/dictionaries/</id>
    <published>2017-10-28T13:17:18.000Z</published>
    <updated>2018-01-10T05:30:54.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典-Dictionaries-简介"><a href="#字典-Dictionaries-简介" class="headerlink" title="字典(Dictionaries)简介"></a>字典(Dictionaries)简介</h2><p>  Python中的字典本质上是包含各种带有唯一标识符的成对信息的列表，可以理解为是一系列的<strong>键—值对</strong>，但与列表不同的是，字典是以<strong>键</strong>（整数、字符串、列表、字典或其他Python 对象）而非索引来引用某个元素，在唯一键值比连续整数更能反映出变量值含义的情况下，这个特点使字典比列表更实用。另外，字典是由花括号<code>{}</code>括起的，而非列表的中括号<code>[]</code>。而更为关键的是，字典不同于列表，字典是没有内置排序的，而列表会根据索引值（连续整数）进行隐式排序，这让字典可以很方便快速的进行搜索或添加操作（计算机不需要重新分配索引），这也让字典比列表更适合处理数据量多的情况。下面是一个简单的字典示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simple_dict = &#123;<span class="string">'one'</span>:1, <span class="string">'two'</span>:2, <span class="string">'three'</span>:3&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #1: &#123;0&#125;"</span>.format(simple_dict)) <span class="comment">#将字典打印出来，包括花括号</span></span><br></pre></td></tr></table></figure></p><h2 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h2><h3 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h3><p>  要获取与键相关联的值，可依次指定字典名和放在方括号内的键<code>dict_name[key]</code>，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtle_0 = &#123;<span class="string">'name'</span>:<span class="string">'Leonardo'</span>, <span class="string">'color'</span>:<span class="string">'blue'</span>, <span class="string">'weapon'</span>:<span class="string">'katana'</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #2: &#123;0&#125;"</span>.format(ninja_turtle_0[<span class="string">'name'</span>])) <span class="comment">#Leonardo</span></span><br></pre></td></tr></table></figure></p><h3 id="添加键—值对"><a href="#添加键—值对" class="headerlink" title="添加键—值对"></a>添加键—值对</h3><p>  字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。下面为<code>ninja_turtle_0</code>添加两项信息：位置的X坐标和Y坐标。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtle_0[<span class="string">'x_position'</span>] = 190</span><br><span class="line">ninja_turtle_0[<span class="string">'y_position'</span>] = 250</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #3: &#123;0&#125;"</span>.format(ninja_turtle_0))</span><br></pre></td></tr></table></figure></p><h3 id="先创建一个空字典"><a href="#先创建一个空字典" class="headerlink" title="先创建一个空字典"></a>先创建一个空字典</h3><p>  使用字典来存储用户提供的数据或在编写能自动生成大量键—值对的代码时，通常都需要先定义一个空字典：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master_rat = &#123;&#125;</span><br><span class="line">master_rat[<span class="string">'name'</span>] = <span class="string">"Splinter"</span></span><br><span class="line">master_rat[<span class="string">'color'</span>] = <span class="string">"grey"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #4: &#123;0&#125;"</span>.format(master_rat))</span><br></pre></td></tr></table></figure></p><h3 id="修改字典中的值"><a href="#修改字典中的值" class="headerlink" title="修改字典中的值"></a>修改字典中的值</h3><p>  要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。例如，修改忍者神龟的位置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtle_0[<span class="string">'x_position'</span>] = 250</span><br><span class="line">ninja_turtle_0[<span class="string">'y_position'</span>] = 200</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #5: &#123;0&#125;, &#123;1&#125;"</span>.format(ninja_turtle_0[<span class="string">'x_position'</span>], ninja_turtle_0[<span class="string">'y_position'</span>]))</span><br></pre></td></tr></table></figure></p><h3 id="删除键—值对"><a href="#删除键—值对" class="headerlink" title="删除键—值对"></a>删除键—值对</h3><p>  对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。这里要注意的是，在使用del语句时，必须指定字典名和要删除的键：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del ninja_turtle_0[<span class="string">'weapon'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #6: &#123;0&#125;"</span>.format(ninja_turtle_0))</span><br></pre></td></tr></table></figure></p><h3 id="由类似对象组成的字典"><a href="#由类似对象组成的字典" class="headerlink" title="由类似对象组成的字典"></a>由类似对象组成的字典</h3><p>  字典存储的是一个对象（忍者神龟里的角色）的多种信息，但你也可以使用字典来存储众多对象的同一种信息。例如，假设你要调查很多人，询问他们最喜欢的编程语言，可使用一个字典来存储这种简单调查的结果，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line">    <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line">    <span class="string">'phil'</span>: <span class="string">'python'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #7: \nSarah's favorite language is "</span> + favorite_languages[<span class="string">'sarah'</span>].title() + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure></p><h2 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h2><h3 id="遍历所有的键—值对"><a href="#遍历所有的键—值对" class="headerlink" title="遍历所有的键—值对"></a>遍历所有的键—值对</h3><p>  使用for循环遍历<code>favorite_languages</code>中的所有键—值对，并逐个打印出每人最喜欢什么编程语言：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #8: "</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(key.title() + <span class="string">"'s favorite language is "</span> + value.title() + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure></p><h3 id="遍历字典中的所有键"><a href="#遍历字典中的所有键" class="headerlink" title="遍历字典中的所有键"></a>遍历字典中的所有键</h3><p>  在不需要使用字典中的值时，可以利用keys()函数提取字典的键。下面来遍历<code>favorite_languages</code>，并将每个被调查者的名字都打印出来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #9: "</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br></pre></td></tr></table></figure></p><h3 id="按顺序遍历字典中的所有键"><a href="#按顺序遍历字典中的所有键" class="headerlink" title="按顺序遍历字典中的所有键"></a>按顺序遍历字典中的所有键</h3><p>  字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序。为此，可使用之前用过的sorted()函数来获得按特定顺序排列的键列表的副本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #10: "</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(favorite_languages.keys()):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"&#123;0&#125;, thank you for taking the poll."</span>.format(name.title()))</span><br></pre></td></tr></table></figure></p><h3 id="遍历字典中的所有值"><a href="#遍历字典中的所有值" class="headerlink" title="遍历字典中的所有值"></a>遍历字典中的所有值</h3><p>  如果你感兴趣的主要是字典包含的值，可使用values()函数，它返回一个值列表，而不包含任何键。例如，如果我们想获得一个列表只包含被调查者选择的各种语言，而不包含被调查者的名字，可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #11: "</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure></p><p>  这里得到的结果会出现两个<code>Python</code>，如果不希望结果中出现重复的元素，可使用集合（set）。集合类似于列表，但每个元素都必须是独一无二的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #12: "</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure></p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><h3 id="字典列表"><a href="#字典列表" class="headerlink" title="字典列表"></a>字典列表</h3><p>  字典<code>ninja_turtle_0</code>中只存储了一个忍者神龟的信息，而需要存储其他忍者神龟的信息，则需要创建一个忍者神龟列表，其中每一个忍者神龟都是一个字典，包含各种相关信息，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtle_0 = &#123;<span class="string">'name'</span>:<span class="string">'Leonardo'</span>, <span class="string">'color'</span>:<span class="string">'blue'</span>, <span class="string">'weapon'</span>:<span class="string">'katana'</span>&#125;</span><br><span class="line">ninja_turtle_1 = &#123;<span class="string">'name'</span>:<span class="string">'Raphael'</span>, <span class="string">'color'</span>:<span class="string">'red'</span>, <span class="string">'weapon'</span>:<span class="string">'sai'</span>&#125;</span><br><span class="line">ninja_turtle_2 = &#123;<span class="string">'name'</span>:<span class="string">'Michelangelo'</span>, <span class="string">'color'</span>:<span class="string">'orange'</span>, <span class="string">'weapon'</span>:<span class="string">'double-cut stick'</span>&#125;</span><br><span class="line">ninja_turtle_3 = &#123;<span class="string">'name'</span>:<span class="string">'Donatello'</span>, <span class="string">'color'</span>:<span class="string">'purple'</span>, <span class="string">'weapon'</span>:<span class="string">'bo'</span>&#125;</span><br><span class="line"></span><br><span class="line">ninja_turtles = [ninja_turtle_0, ninja_turtle_1, ninja_turtle_2, ninja_turtle_3]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #13: "</span>)</span><br><span class="line"><span class="keyword">for</span> ninja_turtle <span class="keyword">in</span> ninja_turtles:</span><br><span class="line">    <span class="built_in">print</span>(ninja_turtle)</span><br></pre></td></tr></table></figure></p><p>  完成忍者神龟字典列表的创建后，我们再用range()生成30个脚帮杂兵：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个空列表</span></span><br><span class="line">foot_ninjas = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建30个脚帮杂兵</span></span><br><span class="line"><span class="keyword">for</span> foot_ninja_num <span class="keyword">in</span> range(30):</span><br><span class="line">    new_foot_ninja = &#123;<span class="string">'color'</span>: <span class="string">'black'</span>, <span class="string">'weapon'</span>:<span class="string">'sword'</span>&#125;</span><br><span class="line">    foot_ninjas.append(new_foot_ninja)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示前5个脚帮杂兵的详细信息，和总数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #14: "</span>)</span><br><span class="line"><span class="keyword">for</span> foot_ninja <span class="keyword">in</span> foot_ninjas[:5]:</span><br><span class="line">    <span class="built_in">print</span>(foot_ninja)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Total number of foot ninjas: "</span> + str(len(foot_ninjas)))</span><br></pre></td></tr></table></figure></p><p>  这里我们还可以利用切片操作，将一部分脚帮杂兵的武器改为弓箭：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #15: "</span>)</span><br><span class="line"><span class="keyword">for</span> foot_ninja <span class="keyword">in</span> foot_ninjas[3:9]:</span><br><span class="line">    <span class="keyword">if</span> foot_ninja[<span class="string">'weapon'</span>] != <span class="string">'bow'</span>:</span><br><span class="line">        foot_ninja[<span class="string">'weapon'</span>] = <span class="string">'bow'</span></span><br><span class="line">    <span class="built_in">print</span>(foot_ninja)</span><br></pre></td></tr></table></figure></p><h3 id="在字典中存储列表"><a href="#在字典中存储列表" class="headerlink" title="在字典中存储列表"></a>在字典中存储列表</h3><p>  有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢？如果使用列表，只能存储要添加的比萨配料；但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。在下面的示例中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键<code>toppings</code>相关联的值:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">'crust'</span>: <span class="string">'thick'</span>,</span><br><span class="line">    <span class="string">'toppings'</span>: [<span class="string">'mushrooms'</span>, <span class="string">'extra cheese'</span>],</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 概述所点的比萨</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #16: \nYou ordered a &#123;0&#125;-crust pizza with the following toppings:"</span>.format(pizza[<span class="string">'crust'</span>]))</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'toppings'</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t"</span> + topping)</span><br></pre></td></tr></table></figure></p><p>  每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。在本章前面有关喜欢的编程语言的示例中，如果将每个人的回答都存储在一个列表中，被调查者就可选择多种喜欢的语言:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">'jen'</span>: [<span class="string">'python'</span>, <span class="string">'ruby'</span>],</span><br><span class="line">    <span class="string">'sarah'</span>: [<span class="string">'c'</span>],</span><br><span class="line">    <span class="string">'edward'</span>: [<span class="string">'ruby'</span>, <span class="string">'go'</span>],</span><br><span class="line">    <span class="string">'phil'</span>: [<span class="string">'python'</span>, <span class="string">'haskell'</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #17: "</span>)</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n&#123;0&#125;'s favorite languages are:"</span>.format(name.title()))</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t&#123;0&#125;"</span>.format(language.title()))</span><br></pre></td></tr></table></figure></p><h3 id="在字典中存储字典"><a href="#在字典中存储字典" class="headerlink" title="在字典中存储字典"></a>在字典中存储字典</h3><p>  可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。例如，如果有多个网站用户，每个都有独特的用户名，可在字典中将用户名作为键，然后将每位用户的信息存储在一个字典中，并将该字典作为与用户名相关联的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;</span><br><span class="line">    <span class="string">'aeinstein'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'albert'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'einstein'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'princeton'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">'mcurie'</span>: &#123;</span><br><span class="line">        <span class="string">'first'</span>: <span class="string">'marie'</span>,</span><br><span class="line">        <span class="string">'last'</span>: <span class="string">'curie'</span>,</span><br><span class="line">        <span class="string">'location'</span>: <span class="string">'paris'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nUsername: &#123;0&#125;"</span>.format(username))</span><br><span class="line">    full_name = user_info[<span class="string">'first'</span>] + <span class="string">" "</span> + user_info[<span class="string">'last'</span>]</span><br><span class="line">    location = user_info[<span class="string">'location'</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tFull name: &#123;0&#125;"</span>.format(full_name.title()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\tLocation: &#123;0&#125;"</span>.format(location.title()))</span><br></pre></td></tr></table></figure></p><p>  需要注意的是，这里表示每位用户的字典的结构都相同，这使得嵌套的字典处理起来更容易。倘若表示每位用户的字典都包含不同的键，for循环内部的代码将更复杂。</p><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字典-Dictionaries-简介&quot;&gt;&lt;a href=&quot;#字典-Dictionaries-简介&quot; class=&quot;headerlink&quot; title=&quot;字典(Dictionaries)简介&quot;&gt;&lt;/a&gt;字典(Dictionaries)简介&lt;/h2&gt;&lt;p&gt;  Pyth
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Python基础02：列表和元组</title>
    <link href="http://gaiusyao.cn/2017/10/28/lists-tuples/"/>
    <id>http://gaiusyao.cn/2017/10/28/lists-tuples/</id>
    <published>2017-10-28T02:42:18.000Z</published>
    <updated>2018-01-10T05:33:11.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列-Sequence-简介"><a href="#序列-Sequence-简介" class="headerlink" title="序列(Sequence)简介"></a>序列(Sequence)简介</h2><p>  序列是Python中最基本的数据结构，一组有顺序的元素的集合。序列中的每个元素都分配一个数字指向它的位置，这个数字被称之为索引，第一个索引是0，第二个索引是1，依此类推。</p><h3 id="基本序列类型"><a href="#基本序列类型" class="headerlink" title="基本序列类型"></a>基本序列类型</h3><p>  Python有6个序列的内置类型，但最常见的是列表(lists)和元组(tuples)。其中，列表是由一系列按特定顺序排列的元素组成，用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。下面是一个简单的列表示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">band = [<span class="string">'Bon Jovi'</span>, <span class="string">'Guns &amp; Roses'</span>, <span class="string">'Radiohead'</span>, <span class="string">'Simple Plan'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #1: &#123;0&#125;"</span>.format(band)) <span class="comment">#将列表打印出来，包括方括号</span></span><br></pre></td></tr></table></figure></p><p>  列表非常适合用于存储在程序运行期间可能变化的数据集，因为列表是可以修改的，但有的时候，也需要创建一系列不可修改的元素。Python将不能修改的值称为<strong>不可变的(immutable)</strong>，而不可变的序列被称为元组，下面是一个简单的元组实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (200, 120)</span><br></pre></td></tr></table></figure></p><h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><p>  大多数序列类型（包括可变序列和不可变序列）都支持下面表个中的操作。</p><table><thead><tr><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>x in s</td><td>如果s包含x，返回True，否则返回False</td></tr><tr><td>x not in s</td><td>如果s包含x，返回False，否则返回True</td></tr><tr><td>s + t</td><td>s和t的并置</td></tr><tr><td>s <em> n or n </em> s</td><td>相当于将s添加到自身n次</td></tr><tr><td>s[i]</td><td>s的第i项，从第0项开始</td></tr><tr><td>s[i:j]</td><td>s的从第i项到第j-1项</td></tr><tr><td>s[i:j:k]</td><td>s的从第i项到第j-1项,间隔为k</td></tr><tr><td>len(s)</td><td>s的长度</td></tr><tr><td>min(s)</td><td>s的最小项</td></tr><tr><td>max(s)</td><td>s的最大项目</td></tr><tr><td>s.index(x [， i [， j]])</td><td>在s中（在索引i之后或索引j之前）的x</td></tr><tr><td>s.count(x)</td><td>s中x的总出现次数</td></tr></tbody></table><h2 id="列表（Lists）元素"><a href="#列表（Lists）元素" class="headerlink" title="列表（Lists）元素"></a>列表（Lists）元素</h2><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>  列表是<strong>有序集合</strong>，因此也可以通过索引访问列表的任何元素，具体形式为<code>list_name[index]</code>。当通过索引访问列表元素时，只返回访问的元素，而不包括方括号和引号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #2: &#123;0&#125;"</span>.format(band[0])) <span class="comment">#列表索引也是从0开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #3: &#123;0&#125;"</span>.format(band[-1])) <span class="comment">#同样可以使用负数索引</span></span><br></pre></td></tr></table></figure></p><p>  同样的，列表也可以进行切片操作，且切片操作会返回一个包含所请求元素的新列表，这意味着切片操作将会返回一个此列表的（浅）拷贝：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #4: &#123;0&#125;"</span>.format(band[-3:]))</span><br></pre></td></tr></table></figure></p><h3 id="使用列表中的各个值"><a href="#使用列表中的各个值" class="headerlink" title="使用列表中的各个值"></a>使用列表中的各个值</h3><p>  可像使用其他变量一样使用列表中的各个值。如可以使用拼接根据列表中的值来创建消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">"My favorite band is "</span> + band[0].title() + <span class="string">"!"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #5: &#123;0&#125;"</span>.format(message))</span><br></pre></td></tr></table></figure></p><p>  运行上面的代码，在<code>Output #4</code>后是message的值，即<code>My favorite band is Bon Jovi！</code></p><h3 id="添加列表元素"><a href="#添加列表元素" class="headerlink" title="添加列表元素"></a>添加列表元素</h3><p>  不同于字符串，创建的列表大多数是动态的，这意味着列表创建后，可以随着程序的运行增删改元素。<br>  Python提供了多种在既有列表中添加新数据的方式，最常用的是使用append()函数在列表末尾添加元素，或使用insert()函数将元素插入到指定位置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">band.append(<span class="string">'Zard'</span>) <span class="comment">#使用append(),将元素附加到列表末尾</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #6: &#123;0&#125;"</span>.format(band)) </span><br><span class="line">band.insert(1, <span class="string">'Sum 41'</span>) <span class="comment">#使用insert(),将元素插入到列表中第二个位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #7: &#123;0&#125;"</span>.format(band))</span><br></pre></td></tr></table></figure></p><h3 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h3><p>  修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。例如，将<code>band[1]</code>重新指定为<code>&#39;Sum 42&#39;</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">band[1] = <span class="string">"Sum 42"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #8: &#123;0&#125;"</span>.format(band[1]))</span><br></pre></td></tr></table></figure></p><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>  经常需要删除列表中的一个或多个元素，可根据位置或值来删除列表中的元素，常见的方法有以下四种：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1：使用del语句删除指定位置的元素</span></span><br><span class="line">del band[1] </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #9: &#123;0&#125;"</span>.format(band)) </span><br><span class="line"><span class="comment">#方法2：使用pop()删除列表末尾的元素，或者更形象的称之为弹出</span></span><br><span class="line">popped_band = band.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #10 (band): &#123;0&#125;"</span>.format(band)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #10 (popped_band): &#123;0&#125;"</span>.format(popped_band)) </span><br><span class="line"><span class="comment">#方法3：使用pop()来删除列表中指定位置的元素</span></span><br><span class="line">first_band = band.pop(0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #11 (band): &#123;0&#125;"</span>.format(band)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #11 (first_band): &#123;0&#125;"</span>.format(first_band)) </span><br><span class="line"><span class="comment">#方法4：使用remove()根据元素值删除元素</span></span><br><span class="line">band.remove(<span class="string">'Simple Plan'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #12 (band): &#123;0&#125;"</span>.format(band))</span><br></pre></td></tr></table></figure></p><h3 id="对列表进行排序"><a href="#对列表进行排序" class="headerlink" title="对列表进行排序"></a>对列表进行排序</h3><p>  列表中的元素排列顺序通常是没有规律的，但又经常有以特定顺序呈现信息的需求，因此需要对列表进行排序。最简单的是通过sort()函数对列表进行排序。假设现在有一个汽车列表，并要让其中的汽车按字母顺序排列。为简化这项任务，我们假设该列表中的所有值都是小写的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #13: &#123;0&#125;"</span>.format(cars))</span><br></pre></td></tr></table></figure></p><p>  sort()永久性地改变了列表元素的排列顺序。现在，汽车是按字母顺序排列的，且再也无法恢复到原来的排列顺序。若想保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用sorted()函数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #14 (sorted): &#123;0&#125;"</span>.format(sorted(cars)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #14 (original): &#123;0&#125;"</span>.format(cars))</span><br></pre></td></tr></table></figure></p><p>  前面都是使用字母顺序排序，若想按与字母顺序相反的顺序显示列表，也可向sort()或sorted()传递参数<code>reverse=True</code>。</p><h3 id="反转列表"><a href="#反转列表" class="headerlink" title="反转列表"></a>反转列表</h3><p>  使用reverse()函数可轻松地反转列表，且可以很方便的恢复，只需要再次调用reverse()即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #15 (reversed): &#123;0&#125;"</span>.format(cars))</span><br><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #15 (original): &#123;0&#125;"</span>.format(cars))</span><br></pre></td></tr></table></figure></p><h3 id="确定列表长度"><a href="#确定列表长度" class="headerlink" title="确定列表长度"></a>确定列表长度</h3><p>  使用len()函数可快速获悉列表的长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #16: &#123;0&#125;"</span>.format(len(cars))) <span class="comment">#4</span></span><br></pre></td></tr></table></figure></p><h3 id="索引错误-IndexError"><a href="#索引错误-IndexError" class="headerlink" title="索引错误(IndexError)"></a>索引错误(IndexError)</h3><p>  使用列表经常易犯索引错误，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"F:/pivotlab/learn_python/lists.py"</span>, line 57, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        band[42]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure></p><p>  索引错误意味着Python无法理解你指定的索引，这时可以尝试将你指定的索引减1，或者索引<code>-1</code>，以检查索引错误是因为多了一位，还是列表为空。</p><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p>  现在假设我们有一个名单，需要将名单中的名字都打印出来。我们可以通过索引分别获取并打印名单中每个名字，但这样会有大量的重复，且每次名单发生变化，都需要修改代码。因此，我们需要使用for循环（将在控制流中深入讨论）去遍历整个列表，逐个打印名单中的名字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtles = [<span class="string">'Leonardo'</span>, <span class="string">'Raphael'</span>, <span class="string">'Michelangelo'</span>, <span class="string">'Donatello'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #17: "</span>)</span><br><span class="line"><span class="keyword">for</span> ninja_turtle <span class="keyword">in</span> ninja_turtles:</span><br><span class="line">    <span class="built_in">print</span>(ninja_turtle)</span><br></pre></td></tr></table></figure></p><p>  在for循环中，可对每个元素执行任何操作。下面来扩展前面的示例，对于每位神龟，都打印一条消息，指出他是一个忍者了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ninja_turtles = [<span class="string">'Leonardo'</span>, <span class="string">'Raphael'</span>, <span class="string">'Michelangelo'</span>, <span class="string">'Donatello'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #18: "</span>)</span><br><span class="line"><span class="keyword">for</span> ninja_turtle <span class="keyword">in</span> ninja_turtles:</span><br><span class="line">    <span class="built_in">print</span>(ninja_turtle.title() + <span class="string">", is a ninja!"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="创建数值列表"><a href="#创建数值列表" class="headerlink" title="创建数值列表"></a>创建数值列表</h3><p>  前面的列表存储的均为字符串，但列表也经常用于存储一组数字，下面先用range()函数生成一些数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #19: "</span>) </span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(1,5):</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></p><p>  可以看到，上述代码只打印了数字1~4，而没有包括5，需要打印1~5，则应写成<code>for value in range(1,6)</code>。<br>  接着，我们通过使用list()函数将range()的结果直接转换为列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#range()中第1、2个参数分别是起始值，第3个参数为步长，从2开始数，然后不断地加2，直到达到或超过终值（11）</span></span><br><span class="line">numbers = list(range(2,11,2)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #20: &#123;0&#125;"</span>.format(numbers))</span><br></pre></td></tr></table></figure></p><p>  使用函数range()几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数（即1~10）的平方：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> square <span class="keyword">in</span> range(1,11):</span><br><span class="line">    squares.append(square**2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #21: &#123;0&#125;"</span>.format(squares))</span><br></pre></td></tr></table></figure></p><p>  前面介绍的生成列表squares的方式包含三行代码，而<strong>列表解析</strong>让你只需编写一行代码就能生成这样的列表。如下列代码所示，列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**2 <span class="keyword">for</span> value <span class="keyword">in</span> range(1,11)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #22: &#123;0&#125;"</span>.format(squares))</span><br></pre></td></tr></table></figure></p><p>  可以利用几个专门用于处理数字列表的Python函数，对列表进行简单的统计计算，例如，你可以轻松地找出数字列表的最大值、最小值和总和：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #23 (min): &#123;0&#125;"</span>.format(min(digits))) <span class="comment">#0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #23 (max): &#123;0&#125;"</span>.format(max(digits))) <span class="comment">#9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #23 (sum): &#123;0&#125;"</span>.format(sum(digits))) <span class="comment">#45</span></span><br></pre></td></tr></table></figure></p><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p>  在前面介绍访问列表元素的时候，已简单地提到了<strong>切片</strong>操作，通过切片，可以很方便地使用列表的一部分元素。下面使用切片进行的遍历列表元素和复制列表的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here are the first three players on my team:"</span>)</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:3]: <span class="comment">#遍历切片</span></span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br><span class="line">other_players = players[3:] <span class="comment">#复制列表的剩余部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here are the other players on my team:"</span>)</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> other_players [:]: <span class="comment">#遍历切片</span></span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br></pre></td></tr></table></figure></p><h2 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h2><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>  元组看起来与列表非常相似，但使用的是圆括号<code>()</code>而非方括号<code>[]</code>来标识。定义元组后，就可以像访问列表元素一样使用索引来访问元组元素。下面的代码定义了一个名为<code>dimensions</code>的元组，存储了一个矩形的长度和宽度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (200, 120)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #24 (length): &#123;0&#125;"</span>.format(dimensions[0]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #24 (width): &#123;0&#125;"</span>.format(dimensions[1]))</span><br></pre></td></tr></table></figure></p><p>  下面来尝试通过<code>dimensions[0] = 250</code>修改元组dimensions中的一个元素，结果将得到一个类型错误(TypeError)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: <span class="string">'tuple'</span> object does not support item assignment</span><br></pre></td></tr></table></figure></p><h3 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h3><p>  像列表一样，也可以使用for循环来遍历元组中的所有值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Output #25: &#123;0&#125;"</span>.format(dimension))</span><br></pre></td></tr></table></figure></p><h3 id="修改元组变量"><a href="#修改元组变量" class="headerlink" title="修改元组变量"></a>修改元组变量</h3><p>  虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (400, 100)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\nModified dimensions:"</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure></p><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列-Sequence-简介&quot;&gt;&lt;a href=&quot;#序列-Sequence-简介&quot; class=&quot;headerlink&quot; title=&quot;序列(Sequence)简介&quot;&gt;&lt;/a&gt;序列(Sequence)简介&lt;/h2&gt;&lt;p&gt;  序列是Python中最基本的数据结构，一
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>Python基础01：变量和简单数据类型</title>
    <link href="http://gaiusyao.cn/2017/10/27/numbers-strings/"/>
    <id>http://gaiusyao.cn/2017/10/27/numbers-strings/</id>
    <published>2017-10-26T16:00:00.000Z</published>
    <updated>2018-01-10T05:33:24.936Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>人生苦短，我用Python。</strong></p><p>  根据<a href="https://octoverse.github.com/" target="_blank" rel="noopener">GitHub2017开发者年度报告</a>，Python已成为了GitHub上第二受欢迎的语言（第一名是JavaScript）。这从一个侧面反映了Python正越来越被广泛地使用，也许是因为越来越多的开发者明白了“生命的可贵”？<br>  作为一名会点编程的产品狗，从大二开始接触Python，但除写爬虫以外，基本没用Python做什么正确的事情。目前对使用Python进行数据分析很感兴趣，计划先把Python基础再过一遍，然后尝试使用Python（或许会结合R）进行数据分析的工作。这里介绍一个IDE——<a href="https://www.anaconda.com/what-is-anaconda/" target="_blank" rel="noopener">Anaconda</a> ,它所提供的包管理和环境管理功能，可以省去不少麻烦，安装配置教程请戳<a href="http://www.jianshu.com/p/eecd77803508" target="_blank" rel="noopener">这儿</a>。安装好Python或Anaconda后，就让我们先从Python的变量和简单数据类型开始：</p><p><em>// 笔者使用的版本为Python3.6.3</em></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>  按照惯例，先从<em>Hello World</em>开始，运行下面的代码，将会显示<code>Hello world</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello world"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="变量和变量值"><a href="#变量和变量值" class="headerlink" title="变量和变量值"></a>变量和变量值</h3><p>  下面尝试使用变量来输出<code>Hello world</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello_world = <span class="string">"Hello world"</span></span><br><span class="line"><span class="built_in">print</span>(hello_world)</span><br><span class="line">hello_world = <span class="string">"Hello Python world"</span></span><br><span class="line"><span class="built_in">print</span>(hello_world)</span><br></pre></td></tr></table></figure></p><p>  这里，我们首先添加了一个名为<code>hello_world</code>的变量，并给其赋值为<code>&quot;Hello world&quot;</code>，接着，又将变量<code>hello_world</code>的值修改为<code>&quot;Hello Python world&quot;</code>。执行这四行代码，将会先后打印<code>Hello world</code>和<code>Hello Python world</code>。因此，在程序中可随时修改变量的值，而Python将始终记录变量的最新值。</p><h3 id="变量的命名和使用"><a href="#变量的命名和使用" class="headerlink" title="变量的命名和使用"></a>变量的命名和使用</h3><p>  在Python中，变量的命名和使用需要遵循一定的规则，违反这些规则将带来不必要的错误，或使得代码变得难以阅读和理解。因此，请务必牢记并遵循以下规则：</p><ul><li>变量名只能包含字母、数值和下划线，且不能以数值打头；</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词；</li><li>不要将Python关键字和函数名用作变量名；</li><li>变量名应既简短又具有描述性，如<code>greeting_message</code>；</li><li>谨慎使用小写字母l和大写字母O，易被误认为是数值1和0;</li><li>变量名宜统一使用小写。</li></ul><p>  另外，请注意不要出现拼写错误（如hello_world拼成了hello_wolrd），因为解释器不会对代码进行拼写检查。一旦出现拼写错误，解释器将会返回一个名称错误（NameError）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name <span class="string">'hello_wolrd'</span> is not defined</span><br></pre></td></tr></table></figure></p><p><em>// 名称错误的出现通常是因为出现拼写错误，或未在使用变量前给其赋值。</em></p><h2 id="数值-Numbers"><a href="#数值-Numbers" class="headerlink" title="数值(Numbers)"></a>数值(Numbers)</h2><p>  Python支持4种数值类型：</p><ul><li>int（整型）：10            </li><li>long（长整型）：51924361L</li><li>float（浮点型）：0.0</li><li>complex（复数）：3.14j</li></ul><p>  其中，整型和浮点型应用的最为广泛，下面就重点介绍着两种数值类型。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 42</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #1: &#123;0&#125;"</span>.format(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #2: &#123;0&#125;"</span>.format(3**4))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #3: &#123;0&#125;"</span>.format(int(8.1)/int(2.7)))</span><br></pre></td></tr></table></figure><p>  <code>Output #1</code>展示了如何将一个整数（数值42）赋给变量x，然后将变量x打印出来。<code>Output #5</code>说明了如何得到3的4次方并将结果打印出来。<code>Output #3</code>演示了将数值转换成整数并进行除法运算的方法。数值通过内置的<code>int</code>函数转换成整数，所以算式变成了8.1除以2.7，结果为3.0。</p><p><em>// format()为格式化函数</em></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>  浮点型即带小数点的数，和整型一样，都是最常用的数值类型，示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #4: &#123;0:.3f&#125;"</span>.format(8.1/2.7))</span><br><span class="line">y = * 4.8</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #5: &#123;0:.1f&#125;"</span>.format(y))</span><br><span class="line">r = 8 / <span class="built_in">float</span>(3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #6: &#123;0:.2f&#125;"</span>.format(r))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #7: &#123;0:.4f&#125;"</span>.format(8.0/3))</span><br></pre></td></tr></table></figure></p><p>  <code>Output #4</code>和<code>Output #6</code>非常相似，除了将两个相除的数保留为浮点数，这样算式就是8.1除以2.7，等于3.000。这个示例中print语句的语法，<code>&quot;{0:.3f}&quot;.format(floating_point_number/floating_point_number)</code>，说明了如何设置print 语句中的小数位数。在这示例中，<code>.3f</code>设定了打印的输出值应该有3位小数。<code>Output #8</code>表示用乘以4.8，将结果赋给变量y，然后将结果打印出来，带有一位小数。这两个浮点数相乘的结果是12，所以打印出的值是12.0。<code>Output #6</code>和<code>Output #7</code>表示以两种方式计算8除以3，结果都是一个浮点数，大约等于2.667。</p><h3 id="常用数值操作"><a href="#常用数值操作" class="headerlink" title="常用数值操作"></a>常用数值操作</h3><table><thead><tr><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>x + y</td><td>加法运算</td></tr><tr><td>x - y</td><td>减法运算</td></tr><tr><td>x * y</td><td>乘法运算</td></tr><tr><td>x / y</td><td>除法运算</td></tr><tr><td>x // y</td><td>x除以y的商向下取整的整数 </td></tr><tr><td>x % y</td><td>取余运算</td></tr><tr><td>-x</td><td>x取负</td></tr><tr><td>+x</td><td>x没有变化</td></tr><tr><td>abs(x)</td><td>x的绝对值</td></tr><tr><td>int(x)</td><td>将x转换为整型</td></tr><tr><td>float(x)</td><td>将x转换为浮点型</td></tr><tr><td>complex(re, im)</td><td>将参数转换为复数，re为复数的实部，im(默认0)为复数的虚部</td></tr><tr><td>c.conjugate()</td><td>复数c的共轭           </td></tr><tr><td>divmod(x, y)</td><td>(x // y， x % y)</td></tr><tr><td>pow(x, y)</td><td>x的y次幂</td></tr><tr><td>x ** y</td><td>x的y次幂</td></tr></tbody></table><h3 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a>math模块</h3><p>  <code>math</code>是一个十分有用的标准模块，可以满足一些常见的数值计算。需要使用math模块时，只需在脚本开头添加<code>from math import [function name]</code>，如<code>from math import exp, log, sqrt</code>添加了exp、log和sqrt三个函数，即可进行乘方、自然对数和平方根的计算。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z = 6</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #8: &#123;0:.4f&#125;"</span>.format(exp(z)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #9: &#123;0:.2f&#125;"</span>.format(<span class="built_in">log</span>(z)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #10: &#123;0:.1f&#125;"</span>.format(sqrt(z)))</span><br></pre></td></tr></table></figure></p><p>  <code>Output #8</code>到<code>Output #10</code>分别输出z的乘方、自然对数和平方根，约为403.4288，1.79，2.4。<br>  关于数学模块和其他标准模块以及内置函数的更多信息，可以参考<a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">Python3标准库</a>。</p><h2 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串(Strings)"></a>字符串(Strings)</h2><p>  字符串就是一系列字符组成的序列，是Python中的另一种基本数据类型。字符串由引号括起，其中的引号可以是单引号，也可以是双引号，甚至是3个单引号或3个双引号。下面是字符串的几个示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #11: &#123;0:s&#125;"</span>.format(<span class="string">'I\'</span>m enjoying learning Python.<span class="string">'))</span></span><br><span class="line"><span class="string">print("Output #12: &#123;0:s&#125;".format("This is a long string. Without the backslash\</span></span><br><span class="line"><span class="string">it would run off of the page on the right in the text editor and be very\</span></span><br><span class="line"><span class="string">difficult to read and edit. By using the backslash you can split the long\</span></span><br><span class="line"><span class="string">string into smaller strings on separate lines so that the whole string is easy\</span></span><br><span class="line"><span class="string">to view in the text editor."))</span></span><br><span class="line"><span class="string">print("Output #13: &#123;0:s&#125;".format('</span><span class="string">''</span>You can use triple single quotes</span><br><span class="line"><span class="keyword">for</span> multi-line comment strings.<span class="string">''</span><span class="string">'))</span></span><br><span class="line"><span class="string">print("Output #14: &#123;0:s&#125;".format("""You can also use triple double quotes</span></span><br><span class="line"><span class="string">for multi-line comment strings."""))</span></span><br></pre></td></tr></table></figure></p><p>  从上面的示例中，我们不难发现，由1个单引号或1个双引号括起的字符串为单行字符串，需要换行的时候，必须在行尾加上<code>\</code>。但这种办法不够稳妥，因为<code>\</code>必须是行尾最后一个字符，如果意外地按了一下空格键，<code>\</code>后面就会出现一个看不见的空格，从而出现语法错误，不能正常运行。而由3个单引号或3个双引号括起的，则为多行字符串，不需要行尾添加<code>\</code>，这个特性也被人用来创建多行注释（并不建议这样做）。下面是字符串的分片和索引，以及几个常用的字符串函数：</p><h3 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h3><p>  字符串可以用过string[X]来索引(X为一整数)。同时可以通过string[X:Y]（X、Y可以为正负整数或空）来进行切片操作，即从字符串总拿出一部分，储存在另一个地方。下面通过代码示例来简单说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gaius_yao = <span class="string">"Product Manager"</span></span><br><span class="line">gaius_yao[0]    <span class="comment"># 'P'，字符串第一个字符</span></span><br><span class="line">gaius_yao[2]    <span class="comment"># 'o'，字符串第二个字符</span></span><br><span class="line">gaius_yao[-1]   <span class="comment"># 'r'，字符串最后一个字符</span></span><br><span class="line">gaius_yao[:7]   <span class="comment"># 'Product'，字符串前七个字符</span></span><br><span class="line">gaius_yao[-7:]  <span class="comment"># 'Manager'，字符串后七个字符</span></span><br></pre></td></tr></table></figure></p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>  split()函数将一个字符串拆分成一个子字符串列表，列表中的子字符串正好可以构成原字符串（列表为Python中的另一种数据类型，属于下一篇的内容）。split()函数可以在括号中使用两个附加参数，分别表示使用哪个字符进行拆分合进行拆分的次数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">"My deliverable is due in May"</span></span><br><span class="line">string1_list1 = string1.split()</span><br><span class="line">string1_list2 = string1.split(<span class="string">" "</span>,2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #15: &#123;0&#125;"</span>.format(string1_list1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #16: FIRST PIECE:&#123;0&#125; SECOND PIECE:&#123;1&#125; THIRD PIECE:&#123;2&#125;"</span>\</span><br><span class="line">.format(string1_list2[0], string1_list2[1], string1_list2[2]))</span><br><span class="line">string2 = <span class="string">"Your,deliverable,is,due,in,June"</span></span><br><span class="line">string2_list = string2.split(<span class="string">','</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #17: &#123;0&#125;"</span>.format(string2_list))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #18: &#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>.format(string2_list[1], string2_list[5],\</span><br><span class="line">string2_list[-1]))</span><br></pre></td></tr></table></figure></p><p>  <code>Output #15</code>中，括号内无附加参数，因此<code>split()</code>函数按默认值（空格字符）进行拆分，又因为字符串中含有5个空格被拆分为6个子字符串。<code>Output #16</code>则包含了两个附加参数<code>&quot; &quot;</code>和<code>2</code>，即只想使用前两个空格进行拆分，生成含有三个子字符串的列表。<code>Output #17</code>和<code>Output #18</code>的附加参数为<code>,</code>，因此在出现逗号的位置拆分字符串。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>  join()函数与split()函数相反，将列表中的子字符串组合成一个字符串。使用时，将一个参数放在join()面前，表示使用这个字符（或字符串）在子字符串之间进行组合：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Output #19: &#123;0&#125;"</span>.format(<span class="string">','</span>.join(string2_list)))</span><br></pre></td></tr></table></figure></p><p>  结果为<code>Your,deliverable,is,due,in,June</code>。</p><h3 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h3><p>  strip()函数可以从字符串的两侧去除空格、制表符和换行符，而想要仅从字符串地方左侧或右侧去除，则需要用到lstrip()或rstrip()函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string3 = <span class="string">" Remove unwanted characters from this string.\t\t \n"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #20: string3: &#123;0:s&#125;"</span>.format(string3))</span><br><span class="line">string3_lstrip = string3.lstrip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #21: lstrip: &#123;0:s&#125;"</span>.format(string3_lstrip))</span><br><span class="line">string3_rstrip = string3.rstrip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #22: rstrip: &#123;0:s&#125;"</span>.format(string3_rstrip))</span><br><span class="line">string3_strip = string3.strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #23: strip: &#123;0:s&#125;"</span>.format(string3_strip))</span><br></pre></td></tr></table></figure></p><p>  strip()函数还可以设置附加参数，以从字符串两端删除其他字符，如<code>Output #25</code>将<code>string4</code>中的<code>&#39;$_-+&#39;</code>字符全部删去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string4 = <span class="string">"$<span class="variable">$Here</span>'s another string that has unwanted characters.__---++"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #24: &#123;0:s&#125;"</span>.format(string4))</span><br><span class="line">string4 = <span class="string">"$<span class="variable">$The</span> unwanted characters have been removed.__---++"</span></span><br><span class="line">string4_strip = string4.strip(<span class="string">'$_-+'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #25: &#123;0:s&#125;"</span>.format(string4_strip))</span><br></pre></td></tr></table></figure></p><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>  replace()函数将字符串中的一个或一组字符替换为另一个或另一组字符。这个函数在括号中使用两个附加参数，第一个参数是要在字符串中查找替换的字符或一组字符，第二个参数是要用来替换掉第一个参数的字符或一组字符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string5 = <span class="string">"Let's replace the spaces in this sentence with other characters."</span></span><br><span class="line">string5_replace = string5.replace(<span class="string">" "</span>, <span class="string">"!@!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #26 (with !@!): &#123;0:s&#125;"</span>.format(string5_replace))</span><br><span class="line">string5_replace = string5.replace(<span class="string">" "</span>, <span class="string">","</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #27 (with commas): &#123;0:s&#125;"</span>.format(string5_replace))</span><br></pre></td></tr></table></figure></p><p>  <code>Output #32</code>展示了如何使用replace()函数将字符串中的空格替换为!@!，而<code>Output #33</code>则展示了如何使用逗号替换字符串中的空格。</p><h3 id="lower-、upper-和capitalize"><a href="#lower-、upper-和capitalize" class="headerlink" title="lower()、upper()和capitalize()"></a>lower()、upper()和capitalize()</h3><p>  lower()和upper()函数分别用来将字符串中的字母转换成小写或大写，而capitalize()函数则是将字符串中的第一个字母变为大写，其余变为小写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string6 = <span class="string">"Here's WHAT Happens WHEN You Use lower."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #28: &#123;0:s&#125;"</span>.format(string6.lower()))</span><br><span class="line">string7 = <span class="string">"Here's what Happens when You Use UPPER."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #29: &#123;0:s&#125;"</span>.format(string7.upper()))</span><br><span class="line">string5 = <span class="string">"here's WHAT Happens WHEN you use Capitalize."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #30: &#123;0:s&#125;"</span>.format(string5.capitalize()))</span><br><span class="line">string5_list = string5.split()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Output #31 (on each word):"</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> string5_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"&#123;0:s&#125;"</span>.format(word.capitalize()))</span><br></pre></td></tr></table></figure></p><p>  <code>Output #28</code>和<code>Output #29</code>通过lower()和upper()，将<code>string6</code>中的所有字母变为小写，<code>string7</code>中的所有字母变为大写。<code>Output #30</code>和<code>Output #31</code>则演示了capitalize()，其中`Output #31用到了<strong>for循环</strong>（在控制流中再详细讨论）将每一个子符串首字母大写。</p><h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>  通过len()函数可以得到字符串的长度，使用方法为<code>len(str)</code>，试运行下方的代码，将会得到终极答案<strong>42</strong>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"the answer to life universe and everything"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The answer is &#123;0&#125;"</span>.format(len(question)))</span><br></pre></td></tr></table></figure></p><p>  本篇文章的代码可从<a href="https://github.com/gaiusyao/pivotlab/tree/master/learn_python" target="_blank" rel="noopener">我的GitHub</a>上获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  &lt;strong&gt;人生苦短，我用Python。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  根据&lt;a href=&quot;https://octoverse.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub2017开发者年度报告&lt;/a&gt;
      
    
    </summary>
    
      <category term="人生苦短，我用Python" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/"/>
    
      <category term="Python基础" scheme="http://gaiusyao.cn/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E7%94%A8Python/Python%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="python3" scheme="http://gaiusyao.cn/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>GTD简介</title>
    <link href="http://gaiusyao.cn/2017/10/21/gtd-intro/"/>
    <id>http://gaiusyao.cn/2017/10/21/gtd-intro/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2018-01-10T05:40:22.545Z</updated>
    
    <content type="html"><![CDATA[<p>  GTD（<a href="http://gettingthingsdone.com/" target="_blank" rel="noopener">Getting Things Done</a>）是一套出色的时间管理系统，其核心理念是以下这段话：</p><blockquote><p>“把所有事情都从你的脑袋里弄出来。在事情出现就做好相关行动的一系列决定，而不是在事情爆发的时候。以合适的类别组织好你的项目的各种提醒以及下一步行动。保持你的系统更新和完整，及时进行回顾，使你在任何时候都能信任你的系统和对任务的处理。”</p></blockquote><p>  可以概括为：<strong>通过记录的方式将各种事情从脑海中移出，将其处理、组织后执行并及时复盘。</strong><br>  GTD说起来复杂，却也简单，只有五个核心步骤：收集、处理、组织、复盘、执行。</p><h2 id="1-五步开始GTD"><a href="#1-五步开始GTD" class="headerlink" title="1.五步开始GTD"></a>1.五步开始GTD</h2><h3 id="1-1-收集"><a href="#1-1-收集" class="headerlink" title="1.1 收集"></a>1.1 收集</h3><p>  把任何需要跟踪、记住、要做的事情全部从大脑中清理出来，放入“收集箱”中。这个“收集箱”可以是笔记本、录音设备、电子文档等可以记录的工具，但首先，每天花上十几分钟，把在你脑中所有的信息、任务、灵感，通通用记录的方式移出，以免内存溢出。在彻底将自己的大脑“清空”后，要对“收集箱”中的信息进行处理。</p><h3 id="1-2-处理"><a href="#1-2-处理" class="headerlink" title="1.2 处理"></a>1.2 处理</h3><p>  对“收集箱”中的信息进行处理，并承诺每周至少处理一次“收集箱”，保证“收集箱”里的信息不会堆积如山。<br>  处理工作要遵循下列原则：</p><ul><li>从第一条信息开始处理；</li><li>每次只处理一条信息；</li><li>将“收集箱”全部清空；</li><li>对于需要执行的项：<ul><li>如果少于两分钟，马上去做（两分钟法则）；</li><li>将重要、紧急的事优先处理，但记住，重要、不紧急的对于长期来说更关键；</li><li>交由他人完成；</li><li>列入计划内，或延期完成。</li></ul></li><li>否则：<ul><li>将其存档以方便查询；</li><li>为它定义合适的目标与情境，以便下一步执行；</li><li>打包送入垃圾桶。</li></ul></li></ul><h3 id="1-3-组织"><a href="#1-3-组织" class="headerlink" title="1.3 组织"></a>1.3 组织</h3><p>  将处理后的记录进行组织，分到下列四种集合中：</p><ul><li><strong>下一步行动（Next actions）：</strong>可以实际采取的下一步行动，其定义和情景应尽可能清晰；</li><li><strong>项目（Projects）：</strong>需要大于一个实际的行动才能达到目的的事就是一个“项目”，使用跟踪以及周期性的回顾来确保每个项目都有一个下一步的行动进行下去；</li><li><strong>等待完成（Waiting for）：</strong>指派给他人完成的事项，需要进行持续跟踪和定期检查；</li><li><strong>将来/可能（Someday/Maybe）：</strong>需要在某种条件、某个时间点下去完成，但不是现在。</li></ul><h3 id="1-4-复盘"><a href="#1-4-复盘" class="headerlink" title="1.4 复盘"></a>1.4 复盘</h3><p>  一般这一步会被译成回顾，但笔者更喜欢将其称为复盘，这是因为复盘是为了更好地总结这次的问题，以便之后不断加以改进。要做好复盘这步，需要达到以下三点：</p><ul><li>保持记录的习惯，记录每日、每周事项的完成情况，和未完成原因；</li><li>在每日、每周、每月结尾的时候对当日、当周、当月的完成情况进行回顾和总结；</li><li>根据实际情况持续调整改进系统，以使其更符合自身情况和不断发展着的变化。</li></ul><h3 id="1-5-执行"><a href="#1-5-执行" class="headerlink" title="1.5 执行"></a>1.5 执行</h3><p>  最后，也是最关键的，去执行吧！否则前面做的一切都是无用功。换句话说，前面的工作都是为了让你在执行的过程中，能更加简单、高效，不会在各种各样的事情中迷失方向。当然了，具体执行的时候，需要一些方法和技巧：</p><ul><li>集中注意力，拒绝干扰，包括微信、微博、蛤乎、邮件等一切能干扰你的东西；</li><li>对决定好的事情，坚决执行，绝不拖延；</li><li>采用番茄工作法（详见（三）番茄工作法）；</li><li>避免多任务，保持单进程，即是说一个时间段只专注于处理一件事，这一点很重要。</li></ul><blockquote><p>“因为我当时是看书还是谁跟我讲了一句很智慧的话，说你手里攥着千头万绪，工作是千头万绪，攥着一千个线头，但是一次针眼只能穿过一条线。”</p></blockquote><h2 id="2-图解GTD流程"><a href="#2-图解GTD流程" class="headerlink" title="2.图解GTD流程"></a>2.图解GTD流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://oxv2o8wp9.bkt.clouddn.com/GTD.png" alt="图解GTD流程" title="">                </div>                <div class="image-caption">图解GTD流程</div>            </figure><h2 id="3-番茄工作法"><a href="#3-番茄工作法" class="headerlink" title="3.番茄工作法"></a>3.番茄工作法</h2><h3 id="3-1-GTD与番茄工作法"><a href="#3-1-GTD与番茄工作法" class="headerlink" title="3.1 GTD与番茄工作法"></a>3.1 GTD与番茄工作法</h3><p>  GTD作为一套时间管理系统，在具体执行上有一定的难度，如果没有一定自我控制能力和较好的时间管理方法，是很难在实践中运用好GTD的。因此，需要一套更易于实践的时间管理方法，以支持GTD在微观层面上的执行，比如<strong>番茄工作法</strong>。</p><h3 id="3-2-番茄工作法简介"><a href="#3-2-番茄工作法简介" class="headerlink" title="3.2 番茄工作法简介"></a>3.2 番茄工作法简介</h3><p>  番茄工作法（<a href="https://en.wikipedia.org/wiki/Pomodoro_Technique" target="_blank" rel="noopener">Pomodoro</a>）是一种简单易行的时间管理方法，由Francesco Cirillo创立。使用番茄工作法，必须要有一个番茄钟，可以选择在某宝上购买实体的，也可以用web或App上的，例如<a href="https://tomato-timer.com/" target="_blank" rel="noopener">tomato-timer</a>，一般一个番茄钟的时间为25分钟（也可以更长）。<br>  另外，番茄不仅能用在工作/学习中，也可以用在休闲娱乐的时候，例如玩游戏或者看剧的时候，每隔25分钟就休息一下。  </p><h3 id="3-3-番茄工作法的步骤"><a href="#3-3-番茄工作法的步骤" class="headerlink" title="3.3 番茄工作法的步骤"></a>3.3 番茄工作法的步骤</h3><h4 id="3-3-1-制作任务清单"><a href="#3-3-1-制作任务清单" class="headerlink" title="3.3.1 制作任务清单"></a>3.3.1 制作任务清单</h4><p>  番茄工作法首先要制订当日的任务清单（也就是当日Todo List），将当天要完成的事情列下来，并分解为若干个番茄。其中，超过4个番茄的任务要分解（个人习惯，可设为超过7个），不足1个的和其他零碎任务组合，直到变为一个完整的番茄。</p><h4 id="3-3-2-专注于任务"><a href="#3-3-2-专注于任务" class="headerlink" title="3.3.2 专注于任务"></a>3.3.2 专注于任务</h4><p>  从任务清单上选择一个待完成的任务，然后开始你的任务，中途不允许被任何与该任务无关的事所打扰，直到番茄时钟响起，然后可以获得一个5分钟的短休息，在四个番茄种后可以获得一个15分钟的长休息奖励。过程中的任何事务性干扰应被记录下来，待番茄钟结束后再去解决。<br><em>// 如受某些不可抗力影响，番茄钟被打断，则需重新开始</em></p><h4 id="3-3-3-填写任务清单"><a href="#3-3-3-填写任务清单" class="headerlink" title="3.3.3 填写任务清单"></a>3.3.3 填写任务清单</h4><p>  在番茄钟结束后，要在完成的任务后打勾，并记录下完成情况。</p><h4 id="3-3-4-放轻松"><a href="#3-3-4-放轻松" class="headerlink" title="3.3.4 放轻松"></a>3.3.4 放轻松</h4><p>  在番茄钟间隔的短休息和长休息中，要好好地放轻松，可以浏览网页、回复信息，总之就是好好调整状态。</p><h4 id="3-3-5-下一个流程"><a href="#3-3-5-下一个流程" class="headerlink" title="3.3.5 下一个流程"></a>3.3.5 下一个流程</h4><p>  结束休息后，应立即、马上地转换状态，投入到下一个流程中。</p><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>  GTD是一套行之有效且需持续实践的系统，需要结合自身情况和不断变化着的实际，对GTD进行不断的迭代，使其成为一个更加可靠、可信赖的系统。在这个过程中，工具的角色虽不是决定性的，但也十分重要。因此笔者拟在完成个人博客的第二期建设后，集中精力开发一款GTD工具（结合番茄工作法），这篇博文就作为该项目的一个开端吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  GTD（&lt;a href=&quot;http://gettingthingsdone.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Getting Things Done&lt;/a&gt;）是一套出色的时间管理系统，其核心理念是以下这段话：&lt;/p&gt;
&lt;block
      
    
    </summary>
    
      <category term="其他文章" scheme="http://gaiusyao.cn/categories/%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="GTD" scheme="http://gaiusyao.cn/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客</title>
    <link href="http://gaiusyao.cn/2017/10/15/hello-world/"/>
    <id>http://gaiusyao.cn/2017/10/15/hello-world/</id>
    <published>2017-10-14T16:00:00.000Z</published>
    <updated>2018-01-10T05:43:58.260Z</updated>
    
    <content type="html"><![CDATA[<p>  今天刚建好博客，还没什么内容可以放上来，就先从如何搭建个人博客（毕竟在这走了不少弯路）开始，写一篇微小的教程吧！<br>首先，笔者的个人博客是使用Hexo + GitHub Pages搭建的。至于为什么要使用Hexo来搭建个人博客，而不是GitHub Pages钦定的jeklly，这和笔者被jeklly坑过完全没关系，主要是Hexo足够快速、简洁和高效。不过这里不展开介绍了，详细介绍可以看<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a>，英语不好的同学点<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">这里</a>。接着，我们先从<strong>Hexo的安装与常用命令</strong>开始，介绍如何使用Hexo + GitHub Pages搭建个人博客。</p><p><em>// 笔者系统环境为win10</em></p><h2 id="1-Hexo的安装与常用命令"><a href="#1-Hexo的安装与常用命令" class="headerlink" title="1.Hexo的安装与常用命令"></a>1.Hexo的安装与常用命令</h2><h3 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h3><p>  在安装Hexo前，需要先安装Noed.js以及Git，如果还未接触过两者，可参考下面的链接。</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载Node.js</a></li><li><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js的安装和配置</a></li><li><a href="https://git-scm.com/download/" target="_blank" rel="noopener">下载Git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">安装Git</a></li></ul><h3 id="1-2-安装Hexo"><a href="#1-2-安装Hexo" class="headerlink" title="1.2 安装Hexo"></a>1.2 安装Hexo</h3><p>  完成Noed.js和Git的安装后，先别急，花几分钟看看如何使用<a href="http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="noopener">NPM</a>，然后在命令行中按下面的代码进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ md hexo/blog <span class="comment"># 创建hexo文件夹，win用户为\</span></span><br><span class="line">$ <span class="built_in">cd</span> hexo <span class="comment"># 进入hexo文件夹</span></span><br><span class="line">$ npm install hexo-cli -g <span class="comment"># 使用 npm 安装 Hexo</span></span><br><span class="line">$ hexo init blog </span><br><span class="line">$ <span class="built_in">cd</span> blog </span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g <span class="comment"># == hexo generate，生成静态网站</span></span><br><span class="line">$ hexo s <span class="comment"># == hexo server，启动服务器</span></span><br></pre></td></tr></table></figure><p>  完成上述操作后，打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>访问结果。</p><h3 id="1-3-Hexo常用命令"><a href="#1-3-Hexo常用命令" class="headerlink" title="1.3 Hexo常用命令"></a>1.3 Hexo常用命令</h3><blockquote><ol><li>hexo g(hexo generate) 生成静态文件</li><li>hexo s(hexo server) 启动本地web服务，用于预览</li><li>hexo d(hexo deploy) 部署到远端（如github）</li><li>hexo n(hexo new) 新建页面或文章</li><li>hexo v(hexo version) 查看版本信息</li><li>hexo help <command> 查看命令帮助</li><li>hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)</li><li>hexo list <type> 列出网站资料</type></li></ol></blockquote><h2 id="2-GitHub-Pages"><a href="#2-GitHub-Pages" class="headerlink" title="2.GitHub Pages"></a>2.GitHub Pages</h2><h3 id="2-1-Github-Pages介绍"><a href="#2-1-Github-Pages介绍" class="headerlink" title="2.1 Github Pages介绍"></a>2.1 Github Pages介绍</h3><p>  GitHub Pages是全球最大同性交友网站<a href="https://github.io" target="_blank" rel="noopener">GitHub</a>免费提供给开发者的一款介绍托管项目的产品，多用于建设个人主页或项目介绍，因为本文侧重讲如何用Hexo + GitHub Pages搭建个人博客，这里就不做太多展开了，想要了解GitHub Pages的同学可以看下面两个链接：</p><ul><li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages主页</a></li><li><a href="http://www.jianshu.com/p/c5d5cb61d4e9" target="_blank" rel="noopener">给懒癌患者看的GitHub Pages手册</a></li></ul><h3 id="2-2-部署Hexo到Github-Pages"><a href="#2-2-部署Hexo到Github-Pages" class="headerlink" title="2.2 部署Hexo到Github Pages"></a>2.2 部署Hexo到Github Pages</h3><p>  最激动人心的一步来了，将Hexo部署到Github Pages后，就可以在你的github.io上看到Hexo搭建的个人博客。不过，首先让我们明确要做什么，基本上部署到Github Pages就是两步：<code>hexo g</code> 生成静态网站和<code>git commit</code>提交代码，但具体操作需要使用hexo deploy或git命令行。</p><h3 id="2-3-使用hexo-deploy部署"><a href="#2-3-使用hexo-deploy部署" class="headerlink" title="2.3 使用hexo deploy部署"></a>2.3 使用hexo deploy部署</h3><p>  使用hexo deploy部署，首先要安装一个拓展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>  接着要在配置文件<code>blog\_config.yml</code>的<code># Deployment</code>下做如下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:jiji262/jiji262.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>  然后在命令行中执行如下代码，即可完成部署。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d <span class="comment"># 等同于hexo deploy</span></span><br></pre></td></tr></table></figure><p><em>// 关于使用hexo deploy部署，可参考<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">这个链接</a></em></p><h3 id="2-4-使用git命令行部署"><a href="#2-4-使用git命令行部署" class="headerlink" title="2.4 使用git命令行部署"></a>2.4 使用git命令行部署</h3><p>  使用git命令行进行部署也很简单，只需要先在<code>blog</code>下创建一个<code>.deploy</code>文件夹，再将创建的<code>repo</code>克隆(clone)到本地，然后按如下代码部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo/blog</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:gaiusyao/gaiusyao.github.io.git .deploy/jiji262.github.io</span><br><span class="line">$ hexo g <span class="comment"># 等同于hexo generate</span></span><br><span class="line">$ cp -R public/* .deploy/gaiusyao.github.io <span class="comment">#拷贝blog/public文件夹内容到git目录下</span></span><br><span class="line">$ <span class="built_in">cd</span> .deploy/jiji262.github.io</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m “update blog”</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h2 id="3-Hexo主题"><a href="#3-Hexo主题" class="headerlink" title="3.Hexo主题"></a>3.Hexo主题</h2><h3 id="3-1-使用Hexo主题"><a href="#3-1-使用Hexo主题" class="headerlink" title="3.1 使用Hexo主题"></a>3.1 使用Hexo主题</h3><p>  使用Hexo非常简单，首先在Hexo官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题页面</a>挑选适合的主题，这里推荐笔者朋友的<a href="https://github.com/GeekaholicLin/hexo-theme-ylion" target="_blank" rel="noopener">yolin</a>主题，然后在blog下使用命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/GeekaholicLin/hexo-theme-ylion.git themes/yolin</span><br></pre></td></tr></table></figure><p>  修改<code>blog</code>目录下的<code>_config.yml</code>配置文件中的<code>theme</code>属性，将其设置为<code>yolin</code>，即可使用新的Hexo主题。</p><h3 id="3-2-Hexo主题配置"><a href="#3-2-Hexo主题配置" class="headerlink" title="3.2 Hexo主题配置"></a>3.2 Hexo主题配置</h3><p>  Hexo主题的配置和你所采用的主题有关，不同的主题需要不同的配置，主题的配置文件是<code>blog\themes</code>文件夹下的<code>_config.yml</code>。下面，以笔者使用的<code>raytaylorism</code>为例，介绍Hexo主题的配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">menu: <span class="comment"># 菜单配置（若不需要某项可直接删除）</span></span><br><span class="line">    - id: home</span><br><span class="line">        link: /</span><br><span class="line">        icon: home</span><br><span class="line">        class: menu-home</span><br><span class="line">    - id: archives</span><br><span class="line">        link: /archives</span><br><span class="line">        icon: archive</span><br><span class="line">        class: menu-archive</span><br><span class="line">    - id: category</span><br><span class="line">        link: javascript:;</span><br><span class="line">        category: <span class="literal">true</span></span><br><span class="line">        icon: bookmark</span><br><span class="line">        class: menu-category</span><br><span class="line">    - id: reading</span><br><span class="line">        link: /reading</span><br><span class="line">        icon: book</span><br><span class="line">        class: menu-reading</span><br><span class="line">    - id: about</span><br><span class="line">        link: /about</span><br><span class="line">        icon: user</span><br><span class="line">        class: menu-about</span><br><span class="line"></span><br><span class="line">color: <span class="comment"># 颜色配置</span></span><br><span class="line">  header: blue</span><br><span class="line">  footer: blue</span><br><span class="line">  page_nav: blue</span><br><span class="line">  side_nav: blue darken-1</span><br><span class="line">  tag: deep-orange lighten-1</span><br><span class="line">  article_title_link: blue</span><br><span class="line">  link: deep-orange</span><br><span class="line">  pagination: deep-orange</span><br><span class="line">  tab: deep-orange</span><br><span class="line">  archive_item: grey</span><br><span class="line">  fab: deep-orange</span><br><span class="line">  fab_2: cyan</span><br><span class="line">  fab_3: orange darken-1</span><br><span class="line">  new: deep-orange</span><br><span class="line">  about_header: blue</span><br><span class="line">  about_title: blue</span><br><span class="line"></span><br><span class="line">archive_yearly: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">copyright: © 2017 Gaius-Yao, All rights reserved. <span class="comment"># 版权信息</span></span><br><span class="line"></span><br><span class="line">disqus_shortname: <span class="comment"># Disqus评论shortname，若为空则不启用</span></span><br><span class="line">duoshuo_shortname: <span class="comment"># 多说shortname，若为空则不启用</span></span><br><span class="line">yungentie_product_key: <span class="comment"># 网易云跟帖productKey，从通用代码中获取，若为空则不启用</span></span><br><span class="line">google_analytics: <span class="comment"># Google分析track id，若为空则不启用</span></span><br><span class="line">tencent_analytics: 63863615 <span class="comment"># 腾讯分析sId，若为空则不启用</span></span><br><span class="line">google_code_prettify: prettify-tomorrow-night-eighties <span class="comment"># 高亮的主题，若为空则使用默认主题</span></span><br><span class="line"></span><br><span class="line">mathjax: <span class="literal">true</span> <span class="comment"># 是否启用MathJax数学公式渲染。如果你确认整个站点的博文都不会用到Latex数学公式，可以将其该项设为false提高页面加载速度</span></span><br><span class="line">page_stat: <span class="literal">true</span> <span class="comment"># 是否启用网页计数器</span></span><br></pre></td></tr></table></figure><h3 id="3-3-创建Hexo主题"><a href="#3-3-创建Hexo主题" class="headerlink" title="3.3 创建Hexo主题"></a>3.3 创建Hexo主题</h3><p>  详见下篇Hexo教程——<a href="#">制作Hexo主题</a>。</p><h2 id="4-写博客"><a href="#4-写博客" class="headerlink" title="4.写博客"></a>4.写博客</h2><h3 id="4-1-创建新文章"><a href="#4-1-创建新文章" class="headerlink" title="4.1 创建新文章"></a>4.1 创建新文章</h3><p>  Hexo写博客极其简单，可以执行下列命令来创建一篇新文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-布局-Layout-和标题-tilte"><a href="#4-2-布局-Layout-和标题-tilte" class="headerlink" title="4.2 布局(Layout)和标题(tilte)"></a>4.2 布局(Layout)和标题(tilte)</h3><p>  Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径：</p><blockquote><ul><li>post:  source/_posts</li><li>page:  source</li><li>draft: source/_drafts</li></ul></blockquote><p>  而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p><p><em>// Hexo 默认以标题做为文件名称，但也可以在<code>_config.yml</code>编辑’new_post_name’修改默认文件名称。</em></p><h3 id="4-3-写作和草稿"><a href="#4-3-写作和草稿" class="headerlink" title="4.3 写作和草稿"></a>4.3 写作和草稿</h3><p>  Hexo写作采用<a href="http://www.jianshu.com/p/075d7cac8fef" target="_blank" rel="noopener">markdown语法</a>，完成后使用<code>hexo g</code>即可生成静态html页面。</p><p>  而使用上一部分提到的<code>draft</code>布局创建的草稿，在建立时会被保存到<code>source/_drafts</code>文件夹，可以通过<code>publish</code>命令将其移到<code>source/_posts</code>文件夹内发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-模板-Scaffold"><a href="#4-4-模板-Scaffold" class="headerlink" title="4.4 模板(Scaffold)"></a>4.4 模板(Scaffold)</h3><p>  在新建文章时，Hexo会根据<code>scaffolds</code>文件夹内相对应的文件（即模板）来建立文件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo <span class="string">"My Gallery"</span></span><br></pre></td></tr></table></figure><p>  在执行这行指令时，Hexo 会尝试在<code>scaffolds</code>文件夹中寻找<code>photo.md</code>，并根据其内容建立文章，以下是可以在模版中使用的变量：</p><blockquote><ul><li>layout: 布局</li><li>title:  标题</li><li>date:   文件建立日期</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  今天刚建好博客，还没什么内容可以放上来，就先从如何搭建个人博客（毕竟在这走了不少弯路）开始，写一篇微小的教程吧！&lt;br&gt;首先，笔者的个人博客是使用Hexo + GitHub Pages搭建的。至于为什么要使用Hexo来搭建个人博客，而不是GitHub Pages钦定的j
      
    
    </summary>
    
      <category term="个人博客" scheme="http://gaiusyao.cn/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://gaiusyao.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
